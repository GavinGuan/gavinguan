Index: OvmfPkg/AcpiPlatformDxe/AcpiPlatform.c
===================================================================
--- OvmfPkg/AcpiPlatformDxe/AcpiPlatform.c	(revision 0)
+++ OvmfPkg/AcpiPlatformDxe/AcpiPlatform.c	(revision 0)
@@ -0,0 +1,998 @@
+/** @file
+  ACPI Platform Driver. If OVMF runs in Xen, find Xen ACPI Tables and publish them.
+  Support both Xen and QEMU.
+
+  Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include "AcpiPlatform.h"
+
+UINTN mEfiAcpiMaxNumTables = EFI_ACPI_MAX_NUM_TABLES;
+
+XEN_ACPI_TABLE_POINTER                  *XenAcpiTablePointerStructure = NULL;
+EFI_XEN_ACPI_TABLE_INSTANCE             *AcpiTableInstance = NULL;
+
+
+/**
+  This function calculates and updates an UINT8 checksum.
+
+  @param  Buffer          Pointer to buffer to checksum
+  @param  Size            Number of bytes to checksum
+  @param  ChecksumOffset  Offset to place the checksum result in
+
+  @return EFI_SUCCESS     The function completed successfully.
+
+**/
+EFI_STATUS
+AcpiPlatformChecksum (
+  IN VOID       *Buffer,
+  IN UINTN      Size,
+  IN UINTN      ChecksumOffset
+  )
+{
+  UINT8 Sum;
+  UINT8 *Ptr;
+
+  //
+  // Check the parameter
+  //
+  if (!ChecksumOffset) {
+    ChecksumOffset = OFFSET_OF (EFI_ACPI_DESCRIPTION_HEADER, Checksum);
+  }
+
+  Sum = 0;
+  //
+  // Initialize pointer
+  //
+  Ptr = Buffer;
+
+  //
+  // set checksum to 0 first
+  //
+  Ptr[ChecksumOffset] = 0;
+
+  //
+  // add all content of buffer
+  //
+  while ((Size--) != 0) {
+    Sum = (UINT8) (Sum + (*Ptr++));
+  }
+  //
+  // set checksum
+  //
+  Ptr                 = Buffer;
+  Ptr[ChecksumOffset] = (UINT8) (0xff - Sum + 1);
+
+  return EFI_SUCCESS;
+}
+
+/**
+  Checksum all versions of the common tables, RSDP, RSDT, XSDT.
+
+  @param  AcpiTableInstance  Instance of the protocol.
+
+  @return EFI_SUCCESS        The function completed successfully.
+
+**/
+EFI_STATUS
+ChecksumCommonTables (
+  IN OUT EFI_XEN_ACPI_TABLE_INSTANCE            *AcpiTableInstance
+  )
+{
+  //
+  // RSDP ACPI 1.0 checksum for 1.0 table.  This is only the first 20 bytes of the structure
+  //
+  AcpiPlatformChecksum (
+    AcpiTableInstance->Rsdp1,
+    sizeof (EFI_ACPI_1_0_ROOT_SYSTEM_DESCRIPTION_POINTER),
+    OFFSET_OF (EFI_ACPI_1_0_ROOT_SYSTEM_DESCRIPTION_POINTER,
+    Checksum)
+    );
+
+  //
+  // RSDP ACPI 1.0 checksum for 2.0/3.0 table.  This is only the first 20 bytes of the structure
+  //
+  AcpiPlatformChecksum (
+    AcpiTableInstance->Rsdp2,
+    sizeof (EFI_ACPI_1_0_ROOT_SYSTEM_DESCRIPTION_POINTER),
+    OFFSET_OF (EFI_ACPI_1_0_ROOT_SYSTEM_DESCRIPTION_POINTER,
+    Checksum)
+    );
+
+  //
+  // RSDP ACPI 2.0/3.0 checksum, this is the entire table
+  //
+  AcpiPlatformChecksum (
+    AcpiTableInstance->Rsdp2,
+    sizeof (EFI_ACPI_2_0_ROOT_SYSTEM_DESCRIPTION_POINTER),
+    OFFSET_OF (EFI_ACPI_2_0_ROOT_SYSTEM_DESCRIPTION_POINTER,
+    ExtendedChecksum)
+    );
+
+  //
+  // RSDT checksums
+  //
+  AcpiPlatformChecksum (
+    AcpiTableInstance->Rsdt1,
+    AcpiTableInstance->Rsdt1->Length,
+    OFFSET_OF (EFI_ACPI_DESCRIPTION_HEADER,
+    Checksum)
+    );
+
+  AcpiPlatformChecksum (
+    AcpiTableInstance->Rsdt2,
+    AcpiTableInstance->Rsdt2->Length,
+    OFFSET_OF (EFI_ACPI_DESCRIPTION_HEADER,
+    Checksum)
+    );
+
+  //
+  // XSDT checksum
+  //
+  AcpiPlatformChecksum (
+    AcpiTableInstance->Xsdt,
+    AcpiTableInstance->Xsdt->Length,
+    OFFSET_OF (EFI_ACPI_DESCRIPTION_HEADER,
+    Checksum)
+    );
+
+  return EFI_SUCCESS;
+}
+
+/**
+  This function creates and adds Xen ACPI tables. 
+  Create and add FADT 1.0 to RSDT;
+  Create and add FADT 2.0 to XSDT;
+  Create and add Secondary Tables(MADT, HPET, TCPA, etc) to RSDT and XSDT;
+  Create and add DSDT and FACS to FACP.
+
+  @param  AcpiTableInstance       Instance of the protocol.
+
+  @return EFI_SUCCESS             The function completed successfully.
+
+**/
+EFI_STATUS
+EFIAPI
+SetAcpiTable (
+  IN EFI_XEN_ACPI_TABLE_INSTANCE           *AcpiTableInstance
+  )
+{
+  EFI_STATUS                               Status;
+  UINT32                                   *CurrentRsdtEntry;
+  VOID                                     *CurrentXsdtEntry;
+  UINT64                                   Buffer64;
+  UINTN                                    TotalSize;
+  EFI_PHYSICAL_ADDRESS                     PageAddress;
+  LIST_ENTRY                               *CurrentList;
+  EFI_XEN_ACPI_SSDT_2_0_TABLE_LIST         *CurrentTable;
+  UINTN                                    RsdtEntryIndex;
+  UINTN                                    XsdtEntryIndex;
+
+  //
+  // Check for invalid input parameters
+  //
+  ASSERT (AcpiTableInstance);
+
+  //
+  // 1. Construct DSDT and FACS
+  //
+  if (XenAcpiTablePointerStructure->XenDsdt2Ptr) {
+    //TotalSize = sizeof (XenAcpiTablePointerStructure->XenDsdt2Ptr->Length);
+    TotalSize = XenAcpiTablePointerStructure->XenDsdt2Ptr->Length;
+    PageAddress = 0xFFFFFFFF;
+    Status = gBS->AllocatePages (
+                    AllocateMaxAddress,
+                    EfiACPIReclaimMemory,
+                    EFI_SIZE_TO_PAGES (TotalSize),
+                    &PageAddress
+                    );
+
+    ZeroMem ((UINT8 *) (UINTN) PageAddress, TotalSize);
+
+    AcpiTableInstance->Dsdt2 = (EFI_ACPI_DESCRIPTION_HEADER *) (UINTN) PageAddress;
+
+    //
+    // Copy Xen DSDT contents to the new DSDT
+    //
+    CopyMem (
+      AcpiTableInstance->Dsdt2,
+      (VOID *) (UINTN) XenAcpiTablePointerStructure->XenDsdt2Ptr,
+      TotalSize
+     );
+
+    //
+    // Checksum the table
+    //
+    AcpiPlatformChecksum (
+      AcpiTableInstance->Dsdt2,
+      AcpiTableInstance->Dsdt2->Length,
+      OFFSET_OF (EFI_ACPI_DESCRIPTION_HEADER,
+      Checksum)
+      );
+  }
+
+  if (XenAcpiTablePointerStructure->XenFacs2Ptr) {
+    TotalSize = sizeof (EFI_ACPI_2_0_FIRMWARE_ACPI_CONTROL_STRUCTURE);
+    PageAddress = 0xFFFFFFFF;
+    Status = gBS->AllocatePages (
+                    AllocateMaxAddress,
+                    EfiACPIMemoryNVS,
+                    EFI_SIZE_TO_PAGES (TotalSize),
+                    &PageAddress
+                    );
+
+    ZeroMem ((UINT8 *) (UINTN) PageAddress, TotalSize);
+
+    AcpiTableInstance->Facs2 = (EFI_ACPI_2_0_FIRMWARE_ACPI_CONTROL_STRUCTURE *) (UINTN) PageAddress;
+
+    //
+    // Copy Xen FACS 2.0 contents to the new FACS 2.0
+    //
+    CopyMem (
+      AcpiTableInstance->Facs2,
+      (VOID *) (UINTN) XenAcpiTablePointerStructure->XenFacs2Ptr,
+      TotalSize
+     );
+
+    //
+    // Checksum the table
+    //
+    AcpiPlatformChecksum (
+      AcpiTableInstance->Facs2,
+      AcpiTableInstance->Facs2->Length,
+      OFFSET_OF (EFI_ACPI_DESCRIPTION_HEADER,
+      Checksum)
+      );
+  }
+
+  //
+  // 2. Set SSDT tables, and then add it to RSDT and XSDT entries
+  //
+  if (!IsListEmpty (&XenAcpiTablePointerStructure->XenSsdtTableList)) {
+    RsdtEntryIndex = 0;
+    XsdtEntryIndex = 0;
+    CurrentList = &XenAcpiTablePointerStructure->XenSsdtTableList;
+
+    do {
+      CurrentList = GetNextNode(&XenAcpiTablePointerStructure->XenSsdtTableList, CurrentList);
+
+      //
+      // Create new table for every secondary table
+      //
+      CurrentTable = (EFI_XEN_ACPI_SSDT_2_0_TABLE_LIST *) (UINTN) CurrentList;
+
+      TotalSize = CurrentTable->Length;
+      PageAddress = 0xFFFFFFFF;
+      Status = gBS->AllocatePages (
+                      AllocateMaxAddress,
+                      EfiACPIReclaimMemory,
+                      EFI_SIZE_TO_PAGES (TotalSize),
+                      &PageAddress
+                      );
+
+      ZeroMem ((UINT8 *) (UINTN) PageAddress, TotalSize);
+
+      //
+      // Copy Xen Acpi table contents to the new table
+      //
+      CopyMem (
+        (VOID *) (UINTN) PageAddress,
+        (VOID *) (UINTN) CurrentTable->XenTablePhysicalAddress,
+        TotalSize
+       );
+
+      //
+      // Checksum the table
+      //
+      AcpiPlatformChecksum (
+        (VOID *) (UINTN) PageAddress,
+        CurrentTable->Length,
+        OFFSET_OF (EFI_ACPI_DESCRIPTION_HEADER,
+        Checksum)
+        );
+
+      //
+      // Add to RSDT 2.0
+      //
+      if (XenAcpiTablePointerStructure->XenFadt1Ptr && RsdtEntryIndex == 0) {
+        //
+        // If FADT 1.0 exists, we keep it the first one and add it later
+        //
+        RsdtEntryIndex = 1;
+      }
+
+      CurrentRsdtEntry  = (UINT32 *) ((UINT8 *) AcpiTableInstance->Rsdt2 + sizeof (EFI_ACPI_DESCRIPTION_HEADER) + RsdtEntryIndex * sizeof (UINT32));
+      *CurrentRsdtEntry = (UINT32) (UINTN) PageAddress;
+
+      //
+      // Add to XSDT 2.0
+      //
+      if (XenAcpiTablePointerStructure->XenFadt1Ptr && XsdtEntryIndex == 0) {
+        //
+        // If FADT 2.0 exists, we keep it the first one and add it later
+        //
+        XsdtEntryIndex = 1;
+      }
+
+      CurrentXsdtEntry  = (VOID *) ((UINT8 *) AcpiTableInstance->Xsdt + sizeof (EFI_ACPI_DESCRIPTION_HEADER) + XsdtEntryIndex * sizeof (UINT64));
+      //
+      // Add entry to XSDT, XSDT expects 64 bit pointers, but
+      // the table pointers in XSDT are not aligned on 8 byte boundary.
+      //
+      Buffer64 = (UINT64) (UINTN) PageAddress;
+      CopyMem (
+        CurrentXsdtEntry,
+        &Buffer64,
+        sizeof (UINT64)
+        );
+
+      RsdtEntryIndex++;
+      XsdtEntryIndex++;
+
+    } while (!IsNodeAtEnd(&XenAcpiTablePointerStructure->XenSsdtTableList, CurrentList));
+  }
+
+  //
+  // 3. Set FADT 1.0, and then add it to RSDT
+  //
+  if (XenAcpiTablePointerStructure->XenFadt1Ptr) {
+    TotalSize = sizeof (EFI_ACPI_1_0_FIXED_ACPI_DESCRIPTION_TABLE);
+    PageAddress = 0xFFFFFFFF;
+    Status = gBS->AllocatePages (
+                    AllocateMaxAddress,
+                    EfiACPIReclaimMemory,
+                    EFI_SIZE_TO_PAGES (TotalSize),
+                    &PageAddress
+                    );
+
+    ZeroMem ((UINT8 *) (UINTN) PageAddress, TotalSize);
+
+    AcpiTableInstance->Fadt1 = (EFI_ACPI_1_0_FIXED_ACPI_DESCRIPTION_TABLE *) (UINTN) PageAddress;
+
+    //
+    // Copy Xen FADT 1.0 contents to the new FADT 1.0
+    //
+    CopyMem (
+      AcpiTableInstance->Fadt1,
+      (VOID *) (UINTN) XenAcpiTablePointerStructure->XenFadt1Ptr,
+      TotalSize
+     );
+
+    if (XenAcpiTablePointerStructure->XenFacs2Ptr) {
+      AcpiTableInstance->Fadt1->FirmwareCtrl = (UINT32) (UINTN) AcpiTableInstance->Facs2;
+    }
+    if (XenAcpiTablePointerStructure->XenDsdt2Ptr) {
+      AcpiTableInstance->Fadt1->Dsdt         = (UINT32) (UINTN) AcpiTableInstance->Dsdt2;
+    }
+
+    //
+    // Checksum the table
+    //
+    AcpiPlatformChecksum (
+      AcpiTableInstance->Fadt1,
+      AcpiTableInstance->Fadt1->Header.Length,
+      OFFSET_OF (EFI_ACPI_DESCRIPTION_HEADER,
+      Checksum)
+      );
+
+    //
+    // Add to RSDT 2.0
+    //
+    CurrentRsdtEntry  = (UINT32 *) ((UINT8 *) AcpiTableInstance->Rsdt2 + sizeof (EFI_ACPI_DESCRIPTION_HEADER));
+    *CurrentRsdtEntry = (UINT32) (UINTN) AcpiTableInstance->Fadt1;
+  }
+
+  //
+  // 4. Set FADT 2.0, and then add it to XSDT
+  //
+  if (XenAcpiTablePointerStructure->XenFadt2Ptr) {
+    TotalSize = sizeof (EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE);
+    PageAddress = 0xFFFFFFFF;
+    Status = gBS->AllocatePages (
+                    AllocateMaxAddress,
+                    EfiACPIReclaimMemory,
+                    EFI_SIZE_TO_PAGES (TotalSize),
+                    &PageAddress
+                    );
+
+    ZeroMem ((UINT8 *) (UINTN) PageAddress, TotalSize);
+
+    AcpiTableInstance->Fadt2 = (EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE *) (UINTN) PageAddress;
+
+    //
+    // Copy Xen FADT 2.0 contents to the new FADT 2.0
+    //
+    CopyMem (
+      AcpiTableInstance->Fadt2,
+      (VOID *) (UINTN) XenAcpiTablePointerStructure->XenFadt2Ptr,
+      TotalSize
+     );
+
+    if (XenAcpiTablePointerStructure->XenFacs2Ptr) {
+      AcpiTableInstance->Fadt2->FirmwareCtrl  = (UINT32) (UINTN) AcpiTableInstance->Facs2;
+      AcpiTableInstance->Fadt2->XFirmwareCtrl = (UINT64) (UINTN) AcpiTableInstance->Facs2;
+    }
+
+    if (XenAcpiTablePointerStructure->XenDsdt2Ptr) {
+      AcpiTableInstance->Fadt2->Dsdt          = (UINT32) (UINTN) AcpiTableInstance->Dsdt2;
+      AcpiTableInstance->Fadt2->XDsdt         = (UINT64) (UINTN) AcpiTableInstance->Dsdt2;
+    }
+
+    //
+    // Checksum the table
+    //
+    AcpiPlatformChecksum (
+      AcpiTableInstance->Fadt2,
+      AcpiTableInstance->Fadt2->Header.Length,
+      OFFSET_OF (EFI_ACPI_DESCRIPTION_HEADER,
+      Checksum)
+      );
+
+    //
+    // Add to XSDT 2.0
+    //
+    CurrentXsdtEntry  = (VOID *) ((UINT8 *) AcpiTableInstance->Xsdt + sizeof (EFI_ACPI_DESCRIPTION_HEADER));
+    //
+    // Add entry to XSDT, XSDT expects 64 bit pointers, but
+    // the table pointers in XSDT are not aligned on 8 byte boundary.
+    //
+    Buffer64 = (UINT64) (UINTN) AcpiTableInstance->Fadt2;
+    CopyMem (
+      CurrentXsdtEntry,
+      &Buffer64,
+      sizeof (UINT64)
+      );
+  }
+
+  return EFI_SUCCESS;
+}
+
+/**
+  This function publishes the specified versions of the Xen ACPI tables by
+  installing EFI configuration table entries for them. Any combination of
+  table versions can be published.
+
+  @param  AcpiTableInstance  Instance of the protocol.
+  @param  Version            Version(s) to publish.
+
+  @return EFI_SUCCESS  The function completed successfully.
+  @return EFI_ABORTED  The function could not complete successfully.
+
+**/
+EFI_STATUS
+EFIAPI
+PublishTables (
+  IN EFI_XEN_ACPI_TABLE_INSTANCE              *AcpiTableInstance,
+  IN EFI_ACPI_TABLE_VERSION                   Version
+  )
+{
+  EFI_STATUS                Status;
+
+  //
+  // Construct all the APCI tables
+  //
+  Status = SetAcpiTable (AcpiTableInstance);
+  if (EFI_ERROR (Status)) {
+    return EFI_ABORTED;
+  }
+
+  //
+  // Do checksum again because Dsdt/Xsdt is updated.
+  //
+  ChecksumCommonTables (AcpiTableInstance);
+
+  //
+  // Add the RSD_PTR to the system table and store that we have installed the
+  // tables.
+  //
+  if (((Version & EFI_ACPI_TABLE_VERSION_1_0B) != 0) &&
+      !AcpiTableInstance->TablesInstalled1) {
+
+    Status = gBS->InstallConfigurationTable (&gEfiAcpi10TableGuid, AcpiTableInstance->Rsdp1);
+    if (EFI_ERROR (Status)) {
+      return EFI_ABORTED;
+    }
+
+    AcpiTableInstance->TablesInstalled1 = TRUE;
+  }
+
+  if (((Version & EFI_ACPI_TABLE_VERSION_2_0) != 0 ||
+       (Version & EFI_ACPI_TABLE_VERSION_3_0) != 0) &&
+      !AcpiTableInstance->TablesInstalled2) {
+    Status = gBS->InstallConfigurationTable (&gEfiAcpiTableGuid, AcpiTableInstance->Rsdp2);
+    if (EFI_ERROR (Status)) {
+      return EFI_ABORTED;
+    }
+
+    AcpiTableInstance->TablesInstalled2= TRUE;
+  }
+
+  return EFI_SUCCESS;
+}
+
+/**
+  Installs an ACPI table into the RSDT/XSDT.
+  Note that the ACPI table should be checksumed before installing it.
+  Otherwise it will assert.
+
+  @param  This                 Protocol instance pointer.
+  @param  AcpiTableBuffer      A pointer to a buffer containing the ACPI table to be installed.
+  @param  AcpiTableBufferSize  Specifies the size, in bytes, of the AcpiTableBuffer buffer.
+  @param  TableKey             Reurns a key to refer to the ACPI table.
+
+  @return EFI_SUCCESS            The table was successfully inserted.
+  @return EFI_INVALID_PARAMETER  Either AcpiTableBuffer is NULL, TableKey is NULL, or AcpiTableBufferSize and the size field embedded in the ACPI table pointed to by AcpiTableBuffer are not in sync.
+  @return EFI_ABORTED            Set Apci Tables error
+  @return EFI_LOAD_ERROR         Insert into configuration tables error
+
+**/
+EFI_STATUS
+EFIAPI
+InstallAcpiTable (
+  IN CONST EFI_ACPI_TABLE_PROTOCOL          *This,
+  IN CONST VOID                             *AcpiTableBuffer,
+  IN       UINTN                            AcpiTableBufferSize,
+  OUT      UINTN                            *TableKey
+  )
+{
+  EFI_STATUS                         Status;
+  EFI_XEN_ACPI_TABLE_INSTANCE        *AcpiTableInstance;
+
+  //
+  // Get the instance of the Xen ACPI table protocol
+  //
+  AcpiTableInstance = EFI_ACPI_TABLE_INSTANCE_FROM_THIS (This);
+
+  //
+  // Construct all the APCI tables
+  //
+  Status = SetAcpiTable (AcpiTableInstance);
+  if (EFI_ERROR (Status)) {
+    return EFI_ABORTED;
+  }
+
+  //
+  // Construct APCI table and install it to configuration table
+  //
+  Status = PublishTables (
+             AcpiTableInstance,
+             EFI_ACPI_TABLE_VERSION_1_0B | EFI_ACPI_TABLE_VERSION_2_0 | EFI_ACPI_TABLE_VERSION_3_0
+             );
+  if (EFI_ERROR (Status)) {
+    gBS->FreePool (AcpiTableInstance);
+    gBS->FreePool (XenAcpiTablePointerStructure);
+    return EFI_LOAD_ERROR;
+  }
+
+  //
+  // Completed successfully
+  //
+  return EFI_SUCCESS;
+}
+
+/**
+  Removes an ACPI table from the RSDT/XSDT.
+
+  @param  This      Protocol instance pointer.
+  @param  TableKey  Specifies the table to uninstall.  The key was returned from InstallAcpiTable().
+
+  @return EFI_SUCCESS    The table was successfully uninstalled.
+
+**/
+EFI_STATUS
+EFIAPI
+UninstallAcpiTable (
+  IN CONST EFI_ACPI_TABLE_PROTOCOL                    *This,
+  IN UINTN                                            TableKey
+  )
+{
+  return EFI_SUCCESS;
+}
+
+/**
+  Constructor for the Xen ACPI table protocol. Initializes instance data.
+
+  @param  AcpiTableInstance       Instance to construct
+
+  @return EFI_SUCCESS             Instance initialized.
+  @return EFI_OUT_OF_RESOURCES    Unable to allocate required resources.
+
+**/
+EFI_STATUS
+XenAcpiTableConstructor (
+  EFI_XEN_ACPI_TABLE_INSTANCE    *AcpiTableInstance
+  )
+{
+  EFI_STATUS                     Status;
+  UINTN                          TotalSize;
+  UINT8                          *Pointer;
+  EFI_PHYSICAL_ADDRESS           PageAddress;
+
+  //
+  // Check for invalid input parameters and global variable
+  //
+  ASSERT (AcpiTableInstance);
+  ASSERT (XenAcpiTablePointerStructure);
+
+  AcpiTableInstance->AcpiTableProtocol.InstallAcpiTable   = InstallAcpiTable;
+  AcpiTableInstance->AcpiTableProtocol.UninstallAcpiTable = UninstallAcpiTable;
+
+  //
+  // Create RSDP, RSDT, XSDT structures
+  // Allocate all buffers
+  //
+  TotalSize = sizeof (EFI_ACPI_1_0_ROOT_SYSTEM_DESCRIPTION_POINTER) +
+      sizeof (EFI_ACPI_2_0_ROOT_SYSTEM_DESCRIPTION_POINTER) +
+      sizeof (EFI_ACPI_DESCRIPTION_HEADER) +      // for ACPI 1.0 RSDT
+      mEfiAcpiMaxNumTables * sizeof (UINT32) +
+      sizeof (EFI_ACPI_DESCRIPTION_HEADER) +      // for ACPI 2.0/3.0 RSDT
+      mEfiAcpiMaxNumTables * sizeof (UINT32) +    // FADT 1.0, (SSDTs), ...
+      sizeof (EFI_ACPI_DESCRIPTION_HEADER) +      // for ACPI 2.0/3.0 XSDT
+      mEfiAcpiMaxNumTables * sizeof (UINT64);     // FADT 2.0, (SSDTs), ...
+
+  //
+  // Allocate memory in the lower 32 bit of address range for
+  // compatibility with ACPI 1.0 OS.
+  //
+  // This is done because ACPI 1.0 pointers are 32 bit values.
+  // ACPI 2.0 OS and all 64 bit OS must use the 64 bit ACPI table addresses.
+  // There is no architectural reason these should be below 4GB, it is purely
+  // for convenience of implementation that we force memory below 4GB.
+  //
+  PageAddress = 0xFFFFFFFF;
+  Status = gBS->AllocatePages (
+                  AllocateMaxAddress,
+                  EfiACPIReclaimMemory,
+                  EFI_SIZE_TO_PAGES (TotalSize),
+                  &PageAddress
+                  );
+
+  if (EFI_ERROR (Status)) {
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  Pointer = (UINT8 *) (UINTN) PageAddress;
+  ZeroMem (Pointer, TotalSize);
+
+  AcpiTableInstance->Rsdp1 = (EFI_ACPI_1_0_ROOT_SYSTEM_DESCRIPTION_POINTER *) Pointer;
+  Pointer += sizeof (EFI_ACPI_1_0_ROOT_SYSTEM_DESCRIPTION_POINTER);
+  AcpiTableInstance->Rsdp2 = (EFI_ACPI_2_0_ROOT_SYSTEM_DESCRIPTION_POINTER *) Pointer;
+  Pointer += sizeof (EFI_ACPI_2_0_ROOT_SYSTEM_DESCRIPTION_POINTER);
+
+  AcpiTableInstance->Rsdt1 = (EFI_ACPI_DESCRIPTION_HEADER *) Pointer;
+  Pointer += (sizeof (EFI_ACPI_DESCRIPTION_HEADER) + EFI_ACPI_MAX_NUM_TABLES * sizeof (UINT32));
+  AcpiTableInstance->Rsdt2 = (EFI_ACPI_DESCRIPTION_HEADER *) Pointer;
+  Pointer += (sizeof (EFI_ACPI_DESCRIPTION_HEADER) + EFI_ACPI_MAX_NUM_TABLES * sizeof (UINT32));
+
+  AcpiTableInstance->Xsdt = (EFI_ACPI_DESCRIPTION_HEADER *) Pointer;
+
+  //
+  // Initialize RSDP 1.0 by copying Xen ACPI RSDP 1.0 table, if it exists
+  // (Not work for Xen now)
+  //
+  if (XenAcpiTablePointerStructure->XenRsdp1Ptr) {
+    CopyMem (
+      AcpiTableInstance->Rsdp1,
+      (VOID *) (UINTN) XenAcpiTablePointerStructure->XenRsdp1Ptr,
+      sizeof (EFI_ACPI_1_0_ROOT_SYSTEM_DESCRIPTION_POINTER)
+     );
+     //
+     // Set the RSDT pointer
+     //
+     AcpiTableInstance->Rsdp1->RsdtAddress = (UINT32) (UINTN) AcpiTableInstance->Rsdt1;
+  }
+
+  //
+  // Initialize RSDP 2.0 by copying Xen ACPI RSDP 2.0 table
+  //
+  if (XenAcpiTablePointerStructure->XenRsdp2Ptr) {
+    CopyMem (
+      AcpiTableInstance->Rsdp2,
+      (VOID *) (UINTN) XenAcpiTablePointerStructure->XenRsdp2Ptr,
+      sizeof (EFI_ACPI_2_0_ROOT_SYSTEM_DESCRIPTION_POINTER)
+     );
+
+     //
+     // Set the RSDT pointer to new address
+     //
+     AcpiTableInstance->Rsdp2->RsdtAddress = (UINT32) (UINTN) AcpiTableInstance->Rsdt2;
+
+     //
+     // Set the XSDT pointer to new address
+     //
+     AcpiTableInstance->Rsdp2->XsdtAddress = (UINT64) (UINTN) AcpiTableInstance->Xsdt;
+  }
+
+  //
+  // Initialize RSDT Header and Entries pointer (1.0/2.0)
+  //
+  if (XenAcpiTablePointerStructure->XenRsdt1Ptr) {
+    //
+    // There is no RSDT 1.0 in Xen ACPI (Not work for Xen now)
+    //
+    CopyMem (
+      AcpiTableInstance->Rsdt1,
+      (VOID *) (UINTN) XenAcpiTablePointerStructure->XenRsdt1Ptr,
+      sizeof (EFI_ACPI_DESCRIPTION_HEADER)
+     );
+  }
+  if (XenAcpiTablePointerStructure->XenRsdt2Ptr) {
+    //
+    // Memory copy all the RSDT 2.0 entries of Xen RSDT
+    //
+    AcpiTableInstance->NumberOfTableEntries2 = XenAcpiTablePointerStructure->XenNumberOfTableEntries2;
+
+    CopyMem (
+      AcpiTableInstance->Rsdt2,
+      (VOID *) (UINTN) XenAcpiTablePointerStructure->XenRsdt2Ptr,
+      sizeof (EFI_ACPI_DESCRIPTION_HEADER) + 
+      AcpiTableInstance->NumberOfTableEntries2 * sizeof (UINT32)
+     );
+  }
+
+  //
+  // Initialize XSDT Header and Entries pointer (1.0/2.0)
+  //
+  if (XenAcpiTablePointerStructure->XenXsdtPtr) {
+    //
+    // Memory copy all the RSDT entries of Xen RSDT
+    //
+    AcpiTableInstance->NumberOfTableEntries2 = XenAcpiTablePointerStructure->XenNumberOfTableEntries2;
+
+    CopyMem (
+      AcpiTableInstance->Xsdt,
+      (VOID *) (UINTN) XenAcpiTablePointerStructure->XenXsdtPtr,
+      sizeof (EFI_ACPI_DESCRIPTION_HEADER) + 
+      AcpiTableInstance->NumberOfTableEntries2 * sizeof (UINT64)
+     );
+  }
+
+  //
+  // Completed successfully
+  //
+  return EFI_SUCCESS;
+}
+
+/**
+  Locate the first instance of a protocol.  If the protocol requested is an
+  FV protocol, then it will return the first FV that contains the ACPI table
+  storage file.
+
+  @param  Instance      Return pointer to the first instance of the protocol
+
+  @return EFI_SUCCESS           The function completed successfully.
+  @return EFI_NOT_FOUND         The protocol could not be located.
+  @return EFI_OUT_OF_RESOURCES  There are not enough resources to find the protocol.
+
+**/
+EFI_STATUS
+LocateFvInstanceWithTables (
+  OUT EFI_FIRMWARE_VOLUME2_PROTOCOL **Instance
+  )
+{
+  EFI_STATUS                    Status;
+  EFI_HANDLE                    *HandleBuffer;
+  UINTN                         NumberOfHandles;
+  EFI_FV_FILETYPE               FileType;
+  UINT32                        FvStatus;
+  EFI_FV_FILE_ATTRIBUTES        Attributes;
+  UINTN                         Size;
+  UINTN                         Index;
+  EFI_FIRMWARE_VOLUME2_PROTOCOL *FvInstance;
+
+  FvStatus = 0;
+
+  //
+  // Locate protocol.
+  //
+  Status = gBS->LocateHandleBuffer (
+                   ByProtocol,
+                   &gEfiFirmwareVolume2ProtocolGuid,
+                   NULL,
+                   &NumberOfHandles,
+                   &HandleBuffer
+                   );
+  if (EFI_ERROR (Status)) {
+    //
+    // Defined errors at this time are not found and out of resources.
+    //
+    return Status;
+  }
+
+  //
+  // Looking for FV with ACPI storage file
+  //
+
+  for (Index = 0; Index < NumberOfHandles; Index++) {
+    //
+    // Get the protocol on this handle
+    // This should not fail because of LocateHandleBuffer
+    //
+    Status = gBS->HandleProtocol (
+                     HandleBuffer[Index],
+                     &gEfiFirmwareVolume2ProtocolGuid,
+                     (VOID**) &FvInstance
+                     );
+    ASSERT_EFI_ERROR (Status);
+
+    //
+    // See if it has the ACPI storage file
+    //
+    Status = FvInstance->ReadFile (
+                           FvInstance,
+                           (EFI_GUID*)PcdGetPtr (PcdAcpiTableStorageFile),
+                           NULL,
+                           &Size,
+                           &FileType,
+                           &Attributes,
+                           &FvStatus
+                           );
+
+    //
+    // If we found it, then we are done
+    //
+    if (Status == EFI_SUCCESS) {
+      *Instance = FvInstance;
+      break;
+    }
+  }
+
+  //
+  // Our exit status is determined by the success of the previous operations
+  // If the protocol was found, Instance already points to it.
+  //
+
+  //
+  // Free any allocated buffers
+  //
+  gBS->FreePool (HandleBuffer);
+
+  return Status;
+}
+
+/**
+  Entrypoint of Acpi Platform driver.
+
+  @param  ImageHandle
+  @param  SystemTable
+
+  @return EFI_SUCCESS
+  @return EFI_LOAD_ERROR
+  @return EFI_OUT_OF_RESOURCES
+
+**/
+EFI_STATUS
+EFIAPI
+AcpiPlatformEntryPoint (
+  IN EFI_HANDLE         ImageHandle,
+  IN EFI_SYSTEM_TABLE   *SystemTable
+  )
+{
+  EFI_STATUS                     Status;
+  EFI_ACPI_TABLE_PROTOCOL        *AcpiTable;
+  EFI_FIRMWARE_VOLUME2_PROTOCOL  *FwVol;
+  INTN                           Instance;
+  EFI_ACPI_COMMON_HEADER         *CurrentTable;
+  UINTN                          TableHandle;
+  UINT32                         FvStatus;
+  UINTN                          TableSize;
+  UINTN                          Size;
+  EFI_XEN_ACPI_TABLE_INSTANCE    *PrivateData;
+
+  Instance     = 0;
+  CurrentTable = NULL;
+  TableHandle  = 0;
+
+  //
+  // Find out the Xen ACPI tables
+  //
+  Status = DetectXenAcpi();
+  if (Status == EFI_SUCCESS) {
+    //
+    // Construct the AcpiTableInstance, and then publish Xen ACPI table
+    // Initialize our protocol
+    //
+    PrivateData = AllocateZeroPool (sizeof (EFI_XEN_ACPI_TABLE_INSTANCE));
+    ASSERT (PrivateData);
+    PrivateData->Signature = EFI_ACPI_TABLE_SIGNATURE;
+
+    //
+    // Call constructors
+    //
+    Status = XenAcpiTableConstructor (PrivateData);
+    if (EFI_ERROR (Status)) {
+      gBS->FreePool (PrivateData);
+      return EFI_LOAD_ERROR;
+    }
+
+    //
+    // Publish Xen ACPI tables
+    //
+    Status = PrivateData->AcpiTableProtocol.InstallAcpiTable (
+                              &PrivateData->AcpiTableProtocol,
+                              NULL,
+                              0,
+                              NULL
+                              );
+
+    if (EFI_ERROR(Status)) {
+      return EFI_ABORTED;
+    }
+  }
+  else {
+    //
+    // Find the AcpiTable protocol
+    //
+    Status = gBS->LocateProtocol (&gEfiAcpiTableProtocolGuid, NULL, (VOID**)&AcpiTable);
+    if (EFI_ERROR (Status)) {
+      return EFI_ABORTED;
+    }
+
+    //
+    // Locate the firmware volume protocol
+    //
+    Status = LocateFvInstanceWithTables (&FwVol);
+    if (EFI_ERROR (Status)) {
+      return EFI_ABORTED;
+    }
+    //
+    // Read tables from the storage file.
+    //
+    while (Status == EFI_SUCCESS) {
+
+      Status = FwVol->ReadSection (
+                        FwVol,
+                        (EFI_GUID*)PcdGetPtr (PcdAcpiTableStorageFile),
+                        EFI_SECTION_RAW,
+                        Instance,
+                        (VOID**) &CurrentTable,
+                        &Size,
+                        &FvStatus
+                        );
+      if (!EFI_ERROR(Status)) {
+        //
+        // Add the table
+        //
+        TableHandle = 0;
+
+        TableSize = ((EFI_ACPI_DESCRIPTION_HEADER *) CurrentTable)->Length;
+        ASSERT (Size >= TableSize);
+
+        //
+        // Checksum ACPI table
+        //
+        AcpiPlatformChecksum ((UINT8*)CurrentTable, TableSize, 0);
+
+        //
+        // Install ACPI table
+        //
+        Status = AcpiTable->InstallAcpiTable (
+                              AcpiTable,
+                              CurrentTable,
+                              TableSize,
+                              &TableHandle
+                              );
+        if (EFI_ERROR(Status)) {
+          return EFI_ABORTED;
+        }
+
+        //
+        // Increment the instance
+        //
+        Instance++;
+        CurrentTable = NULL;
+      }
+    }
+  }
+  return EFI_SUCCESS;
+}
+
Index: OvmfPkg/AcpiPlatformDxe/XenAcpiSupport.c
===================================================================
--- OvmfPkg/AcpiPlatformDxe/XenAcpiSupport.c	(revision 0)
+++ OvmfPkg/AcpiPlatformDxe/XenAcpiSupport.c	(revision 0)
@@ -0,0 +1,360 @@
+/** @file
+  ACPI Platform Driver. If OVMF runs in Xen, find Xen ACPI Tables and publish them.
+  Support both Xen and QEMU.
+
+  Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include "AcpiPlatform.h"
+
+/**
+  This function checks an UINT8 checksum.
+
+  @param  Buffer          Pointer to buffer to checksum
+  @param  Size            Number of bytes to checksum
+
+  @return EFI_SUCCESS     The function completed successfully.
+
+**/
+EFI_STATUS
+VerifyAcpiPlatformChecksum (
+  IN VOID       *Buffer,
+  IN UINTN      Size
+  )
+{
+  UINT8 Sum;
+  UINT8 *Ptr;
+
+  Sum = 0;
+  //
+  // Initialize pointer
+  //
+  Ptr = Buffer;
+
+  //
+  // Add all content of buffer
+  //
+  while ((Size--) != 0) {
+    Sum = (UINT8) (Sum + (*Ptr++));
+  }
+  //
+  // Check checksum
+  //
+  if (Sum != 0){
+    return EFI_CRC_ERROR;
+  }
+
+  return EFI_SUCCESS;
+}
+
+/**
+  Initialize the XenAcpiTablePointer Structure
+
+  @return EFI_SUCCESS             The function completed successfully.
+
+**/
+EFI_STATUS
+EFIAPI
+InitializeXenAcpiTablePointer (
+  VOID
+  )
+{
+  XenAcpiTablePointerStructure->XenRsdp1Ptr = NULL;
+  XenAcpiTablePointerStructure->XenRsdp2Ptr = NULL;  // Xen RSDP 2.0
+  XenAcpiTablePointerStructure->XenRsdt1Ptr = NULL;
+  XenAcpiTablePointerStructure->XenRsdt2Ptr = NULL;  // Xen RSDT 2.0
+  XenAcpiTablePointerStructure->XenXsdtPtr  = NULL;  // Xen XSDT 2.0
+  XenAcpiTablePointerStructure->XenFadt1Ptr = NULL;  // Xen FADT 1.0
+  XenAcpiTablePointerStructure->XenFadt2Ptr = NULL;  // Xen FADT 2.0
+  XenAcpiTablePointerStructure->XenFacs1Ptr = NULL;
+  XenAcpiTablePointerStructure->XenFacs2Ptr = NULL;  // Xen FACS 2.0
+  XenAcpiTablePointerStructure->XenDsdt1Ptr = NULL;
+  XenAcpiTablePointerStructure->XenDsdt2Ptr = NULL;  // Xen DSDT
+
+  XenAcpiTablePointerStructure->XenNumberOfTableEntries1 = 0;
+  XenAcpiTablePointerStructure->XenNumberOfTableEntries2 = 0;
+
+  return EFI_SUCCESS;
+}
+
+/**
+  Figures out if Xen hvmloader provides ACPI Table for HVM. If it provides, get the pointers of each table
+
+  @return EFI_SUCCESS             The function completed successfully.
+
+**/
+EFI_STATUS
+EFIAPI
+DetectXenAcpiTable (
+  VOID
+  )
+{
+  UINTN                                        XenAcpiPtr;
+
+  EFI_ACPI_2_0_ROOT_SYSTEM_DESCRIPTION_POINTER *Rsdp2Structure;
+  EFI_ACPI_2_0_RSDT                            *Rsdt2Structure; //Ptr to RSDT2 header
+  EFI_ACPI_2_0_XSDT                            *XsdtStructure;  //Ptr to XSDT2 header
+  EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE    *Fadt2Structure; //Ptr to FADT header
+  EFI_ACPI_DESCRIPTION_HEADER                  *AcpiTableHeader; //Ptr to DSDT header
+
+  EFI_ACPI_TABLE_VERSION                       Version;
+  EFI_STATUS                                   Status;
+  EFI_XEN_ACPI_SSDT_2_0_TABLE_LIST             *CurrentTableList;
+  UINT64                                       Buffer64;
+  UINTN                                        Index;
+  UINT8                                        Length;
+
+  //
+  // Initialize the XEN_ACPI_TABLE_POINTER
+  //
+  InitializeXenAcpiTablePointer();
+  InitializeListHead (&XenAcpiTablePointerStructure->XenSsdtTableList);
+
+  //
+  // Detect the RSDP table
+  //
+  for (XenAcpiPtr = XEN_ACPI_PHYSICAL_ADDRESS; XenAcpiPtr < XEN_BIOS_PHYSICAL_END; XenAcpiPtr += 0x10) {
+
+    Rsdp2Structure = (EFI_ACPI_2_0_ROOT_SYSTEM_DESCRIPTION_POINTER *) (UINTN) XenAcpiPtr;
+
+    if (!AsciiStrnCmp ((CHAR8 *) &Rsdp2Structure->Signature, "RSD PTR ", 8)) {
+      //
+      // Detect the Acpi Version
+      //
+      Version = Rsdp2Structure->Revision;
+
+      //
+      // RSDP ACPI 1.0 checksum for 2.0/3.0 table.  This is only the first 20 bytes of the structure
+      //
+      Status = VerifyAcpiPlatformChecksum (
+        Rsdp2Structure,
+        sizeof (EFI_ACPI_1_0_ROOT_SYSTEM_DESCRIPTION_POINTER)
+        );
+
+      //
+      // For RSDP 2.0 (Xen-4.2 only has a RSDP 2.0 table)
+      //
+      if (Version >= 2) {
+
+        //
+        // RSDP ACPI 2.0/3.0 checksum, this is the entire table
+        //
+        Status = VerifyAcpiPlatformChecksum (
+          Rsdp2Structure,
+          sizeof (EFI_ACPI_2_0_ROOT_SYSTEM_DESCRIPTION_POINTER)
+          );
+
+        if (Status != EFI_SUCCESS) {
+          break;
+        }
+
+        //
+        // Get Xen RSDP pointer, and then RSDT2.0 and XSDT pointers
+        //
+        XenAcpiTablePointerStructure->XenRsdp2Ptr = Rsdp2Structure;
+        XenAcpiTablePointerStructure->XenRsdt2Ptr = (EFI_ACPI_DESCRIPTION_HEADER *) (UINTN) Rsdp2Structure->RsdtAddress;
+        XenAcpiTablePointerStructure->XenXsdtPtr  = (EFI_ACPI_DESCRIPTION_HEADER *) (UINTN) Rsdp2Structure->XsdtAddress;
+
+        //
+        // Detect the RSDT table, get the FADT 1.0 pointer
+        //
+        Rsdt2Structure = (EFI_ACPI_2_0_RSDT *) (UINTN) XenAcpiTablePointerStructure->XenRsdt2Ptr;
+
+        if (!AsciiStrnCmp ((CHAR8 *) &Rsdt2Structure->Header.Signature, "RSDT", 4)) {
+
+          Status = VerifyAcpiPlatformChecksum (
+            Rsdt2Structure,
+            Rsdt2Structure->Header.Length
+            );
+
+          if (Status != EFI_SUCCESS) {
+            break;
+          }
+
+          //
+          // The first one is FADT 1.0 table
+          //
+          XenAcpiTablePointerStructure->XenFadt1Ptr = (EFI_ACPI_1_0_FIXED_ACPI_DESCRIPTION_TABLE *) (UINTN) Rsdt2Structure->Entry[0];
+
+          //
+          // Calculate the Number tables pointed by RSDT/XSDT (FADT1.0/2.0 and SSDTs)
+          //
+          XenAcpiTablePointerStructure->XenNumberOfTableEntries2 = (XenAcpiTablePointerStructure->XenRsdt2Ptr->Length - sizeof (EFI_ACPI_DESCRIPTION_HEADER)) / sizeof (UINT32);
+        }
+
+        //
+        // Detect the XSDT 2.0 table, get the FADT 2.0 pointer
+        //
+        XsdtStructure = (EFI_ACPI_2_0_XSDT *) (UINTN) XenAcpiTablePointerStructure->XenXsdtPtr;
+
+        if (!AsciiStrnCmp ((CHAR8 *) &XsdtStructure->Header.Signature, "XSDT", 4)) {
+
+          Status = VerifyAcpiPlatformChecksum (
+            XsdtStructure,
+            XsdtStructure->Header.Length
+            );
+
+          if (Status != EFI_SUCCESS) {
+            break;
+          }
+
+          //
+          // The first one is FADT 2.0 table
+          //
+          CopyMem (
+            &Buffer64,
+            (VOID *) (UINTN) XenAcpiTablePointerStructure->XenXsdtPtr + sizeof(EFI_ACPI_DESCRIPTION_HEADER),
+            sizeof (UINT64)
+           );
+
+           XenAcpiTablePointerStructure->XenFadt2Ptr = (EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE *) (UINTN) HIGH_32_BITS(Buffer64);
+           Fadt2Structure = XenAcpiTablePointerStructure->XenFadt2Ptr;
+
+
+          //
+          // Following tables are the Secondary System Description Tables (SSDT), we use a list to store them
+          // RSDT 2.0 and XSDT 2.0 share the same SSDT in Xen-4.2
+          //
+          Length = XenAcpiTablePointerStructure->XenNumberOfTableEntries2;
+          for (Index = 1; Index < Length; Index++) {
+            //
+            // Create a new list entry
+            //
+            CurrentTableList = AllocatePool (sizeof (EFI_XEN_ACPI_SSDT_2_0_TABLE_LIST));
+            ASSERT (CurrentTableList);
+
+            CopyMem (
+              &Buffer64,
+              (VOID *) (UINTN) XenAcpiTablePointerStructure->XenXsdtPtr + sizeof(EFI_ACPI_DESCRIPTION_HEADER) + Index * sizeof (UINT64),
+              sizeof (UINT64)
+             );
+            CurrentTableList->XenTablePhysicalAddress = (UINTN) HIGH_32_BITS(Buffer64);
+
+            AcpiTableHeader = (EFI_ACPI_DESCRIPTION_HEADER *) (UINTN) CurrentTableList->XenTablePhysicalAddress;
+
+            //
+            // If we find MADT, HPET, TCPA tables
+            //
+            if (!AsciiStrnCmp ((CHAR8 *) &AcpiTableHeader->Signature, "APIC", 4) ||
+                !AsciiStrnCmp ((CHAR8 *) &AcpiTableHeader->Signature, "HPET", 4) ||
+                !AsciiStrnCmp ((CHAR8 *) &AcpiTableHeader->Signature, "TCPA", 4)) {
+              CurrentTableList->Signature = AcpiTableHeader->Signature;
+              CurrentTableList->Length = AcpiTableHeader->Length;
+            }
+            else {
+              //
+              // For other tables found in secondary tables 
+              //
+              CurrentTableList->Signature = 0;
+              if ((Index + 1) < Length) {
+                CurrentTableList->Length = XsdtStructure->Entry[Index+1] - XsdtStructure->Entry[Index];
+              }
+              else{
+                //
+                // The last table ( We find the secondary tables is located directly adjacent to XSDT table in Xen ACPI)
+                //
+                CurrentTableList->Length = (UINTN) (XenAcpiTablePointerStructure->XenXsdtPtr) - XsdtStructure->Entry[Index];
+              }
+            }
+            //
+            // Add the table to the current list of tables
+            //
+
+            InsertTailList (&XenAcpiTablePointerStructure->XenSsdtTableList, &CurrentTableList->Link);
+          }
+
+          //
+          // Detect the FADT 2.0, then get the DSDT and FACS 2.0
+          // FADT 1.0 and FADT 2.0 point to the same DSDT and FACS 2.0 in Xen-4.2
+          //
+          Fadt2Structure = (EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE *) (UINTN) XenAcpiTablePointerStructure->XenFadt2Ptr;
+
+          if (!AsciiStrnCmp ((CHAR8 *) &Fadt2Structure->Header.Signature, "FACP", 4)) {
+
+            Status = VerifyAcpiPlatformChecksum (
+              Fadt2Structure,
+              Fadt2Structure->Header.Length
+              );
+
+            if (Status != EFI_SUCCESS) {
+              break;
+            }
+
+            XenAcpiTablePointerStructure->XenFacs2Ptr = (EFI_ACPI_2_0_FIRMWARE_ACPI_CONTROL_STRUCTURE *) (UINTN) Fadt2Structure->FirmwareCtrl;
+            XenAcpiTablePointerStructure->XenDsdt2Ptr = (EFI_ACPI_DESCRIPTION_HEADER *) (UINTN) Fadt2Structure->Dsdt;
+          }
+        }
+      }
+      else {
+
+        //
+        // RSDP 1.0 reserved.
+        //
+        if (Status != EFI_SUCCESS) {
+          break;
+        }
+      }
+    }
+  }
+
+  return EFI_SUCCESS;
+}
+
+/**
+  Entry point of the ACPI table driver.
+  Creates and initializes an instance of the ACPI Table
+  Protocol and installs it on a new handle.
+
+  @return EFI_SUCCESS           Driver initialized successfully.
+  @return EFI_LOAD_ERROR        Failed to Initialize or has been loaded.
+
+**/
+EFI_STATUS
+EFIAPI
+DetectXenAcpi (
+  VOID
+  )
+{
+  EFI_HOB_GUID_TYPE              *GuidHob;
+
+  //
+  // See if a XenInfo HOB is available
+  //
+  GuidHob = GetFirstGuidHob (&gEfiXenInfoGuid);
+  if (GuidHob != NULL) {
+    //
+    // We are running in Xen. Detect Xen ACPI table and get the pointer
+    //
+    XenAcpiTablePointerStructure = AllocateZeroPool (sizeof (XEN_ACPI_TABLE_POINTER));
+    ASSERT (XenAcpiTablePointerStructure);
+
+    InitializeXenAcpiTablePointer();
+    DetectXenAcpiTable();
+
+    //
+    // If RSDP is found, we can get the Xen ACPI Tables
+    //
+    if (XenAcpiTablePointerStructure->XenRsdp1Ptr || XenAcpiTablePointerStructure->XenRsdp2Ptr) {
+
+      //
+      // Get Xen ACPI table successfully
+      //
+      return EFI_SUCCESS;
+    }
+    else {
+      gBS->FreePool (XenAcpiTablePointerStructure);
+    }
+  }
+
+  return EFI_NOT_FOUND;
+}
+
Index: OvmfPkg/AcpiPlatformDxe/AcpiPlatform.h
===================================================================
--- OvmfPkg/AcpiPlatformDxe/AcpiPlatform.h	(revision 0)
+++ OvmfPkg/AcpiPlatformDxe/AcpiPlatform.h	(revision 0)
@@ -0,0 +1,160 @@
+/** @file
+  ACPI Platform Driver. Publish Xen ACPI Table inside OVMF. Support both Xen and QEMU.
+
+  Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#ifndef _ACPI_PLATFORM_DXE_H_
+#define _ACPI_PLATFORM_DXE_H_
+
+#include <PiDxe.h>
+
+#include <Protocol/AcpiTable.h>
+#include <Guid/Acpi.h>
+#include <Protocol/AcpiSystemDescriptionTable.h>
+#include <Protocol/DxeSmmReadyToLock.h>
+#include <Protocol/FirmwareVolume2.h>
+
+#include <Library/BaseLib.h>
+#include <Library/DebugLib.h>
+#include <Library/UefiLib.h>
+#include <Library/BaseMemoryLib.h>
+#include <Library/UefiDriverEntryPoint.h>
+#include <Library/MemoryAllocationLib.h>
+#include <Library/UefiBootServicesTableLib.h>
+#include <Library/PcdLib.h>
+#include <Library/HobLib.h>
+#include <IndustryStandard/Acpi.h>
+
+
+#define XEN_ACPI_PHYSICAL_ADDRESS         0x000EA020
+#define XEN_BIOS_PHYSICAL_END             0x000FFFFF
+
+extern EFI_GUID gEfiXenInfoGuid;
+
+//
+// The maximum number of tables this driver supports
+//
+#define EFI_ACPI_MAX_NUM_TABLES 20
+
+//
+// Macro to get the high 32 bits of a 64 bit address
+//
+#define HIGH_PART             0x00000000FFFFFFFFULL
+#define HIGH_32_BITS(a)       ( (a) & HIGH_PART )
+
+//
+// Protocol private structure definition
+//
+//
+// ACPI support protocol instance signature definition.
+//
+#define EFI_ACPI_TABLE_SIGNATURE  SIGNATURE_32 ('S', 'T', 'A', 'E')
+
+//
+// Xen ACPI support protocol instance data structure
+//
+typedef struct {
+  UINTN                                         Signature;
+  EFI_ACPI_1_0_ROOT_SYSTEM_DESCRIPTION_POINTER  *Rsdp1;                 // Pointer to RSD_PTR structure
+  EFI_ACPI_2_0_ROOT_SYSTEM_DESCRIPTION_POINTER  *Rsdp2;                 // Pointer to RSD_PTR structure
+  EFI_ACPI_DESCRIPTION_HEADER                   *Rsdt1;                 // Pointer to RSDT table header
+  EFI_ACPI_DESCRIPTION_HEADER                   *Rsdt2;                 // Pointer to RSDT table header
+  EFI_ACPI_DESCRIPTION_HEADER                   *Xsdt;                  // Pointer to XSDT table header
+  EFI_ACPI_1_0_FIXED_ACPI_DESCRIPTION_TABLE     *Fadt1;                 // Pointer to FADT table header
+  EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE     *Fadt2;                 // Pointer to FADT table header
+  EFI_ACPI_1_0_FIRMWARE_ACPI_CONTROL_STRUCTURE  *Facs1;                 // Pointer to FACS table header
+  EFI_ACPI_2_0_FIRMWARE_ACPI_CONTROL_STRUCTURE  *Facs2;                 // Pointer to FACS table header
+  EFI_ACPI_DESCRIPTION_HEADER                   *Dsdt1;                 // Pointer to DSDT table header
+  EFI_ACPI_DESCRIPTION_HEADER                   *Dsdt2;                 // Pointer to DSDT table header
+  UINTN                                         NumberOfTableEntries1;  // Number of ACPI 1.0 tables
+  UINTN                                         NumberOfTableEntries2;  // Number of ACPI 2.0 tables
+  BOOLEAN                                       TablesInstalled1;       // ACPI 1.0 tables published
+  BOOLEAN                                       TablesInstalled2;       // ACPI 2.0 tables published
+  EFI_ACPI_TABLE_PROTOCOL                       AcpiTableProtocol;
+} EFI_XEN_ACPI_TABLE_INSTANCE;
+
+//
+// ACPI table protocol instance containing record macro
+//
+#define EFI_ACPI_TABLE_INSTANCE_FROM_THIS(a) \
+  CR (a, \
+      EFI_XEN_ACPI_TABLE_INSTANCE, \
+      AcpiTableProtocol, \
+      EFI_ACPI_TABLE_SIGNATURE \
+      )
+
+//
+// RSDT 2.0/3.0
+//
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER                   Header;
+  UINT32                                        Entry[1];
+} EFI_ACPI_2_0_RSDT;
+
+//
+// XSDT 2.0/3.0
+//
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER                   Header;
+  UINT64                                        Entry[1];
+} EFI_ACPI_2_0_XSDT;
+
+//
+// Common structure for Secondary System Description Tables (SSDT 2.0),
+// probably including MADT, HPET, TCPA, ...
+//
+typedef struct {
+  LIST_ENTRY                                    Link;
+  UINT32                                        Signature;
+  UINT32                                        Length;
+  UINTN                                         XenTablePhysicalAddress;
+} EFI_XEN_ACPI_SSDT_2_0_TABLE_LIST;
+
+//
+// Xen ACPI pointer
+//
+typedef struct {
+  EFI_ACPI_1_0_ROOT_SYSTEM_DESCRIPTION_POINTER  *XenRsdp1Ptr;                 // Pointer to Xen RSD_PTR structure
+  EFI_ACPI_2_0_ROOT_SYSTEM_DESCRIPTION_POINTER  *XenRsdp2Ptr;                 // Pointer to Xen RSD_PTR structure
+  EFI_ACPI_DESCRIPTION_HEADER                   *XenRsdt1Ptr;                 // Pointer to Xen RSDT table header
+  EFI_ACPI_DESCRIPTION_HEADER                   *XenRsdt2Ptr;                 // Pointer to Xen RSDT table header
+  EFI_ACPI_DESCRIPTION_HEADER                   *XenXsdtPtr;                  // Pointer to Xen XSDT table header
+  EFI_ACPI_1_0_FIXED_ACPI_DESCRIPTION_TABLE     *XenFadt1Ptr;                 // Pointer to Xen FADT table header
+  EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE     *XenFadt2Ptr;                 // Pointer to Xen FADT table header
+  EFI_ACPI_1_0_FIRMWARE_ACPI_CONTROL_STRUCTURE  *XenFacs1Ptr;                 // Pointer to Xen FACS table header
+  EFI_ACPI_2_0_FIRMWARE_ACPI_CONTROL_STRUCTURE  *XenFacs2Ptr;                 // Pointer to Xen FACS table header
+  EFI_ACPI_DESCRIPTION_HEADER                   *XenDsdt1Ptr;                 // Pointer to Xen DSDT table header
+  EFI_ACPI_DESCRIPTION_HEADER                   *XenDsdt2Ptr;                 // Pointer to Xen DSDT table header
+  LIST_ENTRY                                    XenSsdtTableList;             // Link all the Xen SSDT tables
+  UINTN                                         XenNumberOfTableEntries1;     // Number of Xen ACPI 1.0 tables
+  UINTN                                         XenNumberOfTableEntries2;     // Number of Xen ACPI 2.0 tables
+} XEN_ACPI_TABLE_POINTER;
+
+extern XEN_ACPI_TABLE_POINTER      *XenAcpiTablePointerStructure;
+
+/**
+  Entry point of the ACPI table driver.
+  Creates and initializes an instance of the ACPI Table
+  Protocol and installs it on a new handle.
+
+  @return EFI_SUCCESS           Driver initialized successfully.
+  @return EFI_LOAD_ERROR        Failed to Initialize or has been loaded.
+
+**/
+EFI_STATUS
+EFIAPI
+DetectXenAcpi (
+  VOID
+  );
+
+#endif
Index: OvmfPkg/AcpiPlatformDxe/AcpiPlatformDxe.inf
===================================================================
--- OvmfPkg/AcpiPlatformDxe/AcpiPlatformDxe.inf	(revision 0)
+++ OvmfPkg/AcpiPlatformDxe/AcpiPlatformDxe.inf	(revision 0)
@@ -0,0 +1,66 @@
+## @file
+#  ACPI Platform Driver. Publish Xen ACPI Table inside OVMF. Support both Xen and QEMU.
+#
+#  Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+#
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution.  The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php
+#  
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#  
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = AcpiPlatform
+  FILE_GUID                      = 43df49bc-4e5c-47f2-af8d-bcc0e9725343
+  MODULE_TYPE                    = DXE_DRIVER
+  VERSION_STRING                 = 1.0
+  ENTRY_POINT                    = AcpiPlatformEntryPoint
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64 IPF EBC
+#
+
+[Sources]
+  AcpiPlatform.h
+  AcpiPlatform.c
+  XenAcpiSupport.c
+
+[Packages]
+  MdePkg/MdePkg.dec
+  MdeModulePkg/MdeModulePkg.dec
+  OvmfPkg/OvmfPkg.dec
+
+[LibraryClasses]
+  UefiLib
+  DxeServicesLib
+  PcdLib
+  BaseMemoryLib
+  DebugLib
+  UefiBootServicesTableLib
+  UefiDriverEntryPoint
+  MemoryAllocationLib
+  BaseLib
+  HobLib
+
+[Guids]
+  gEfiAcpi10TableGuid                           # ALWAYS_CONSUMED
+  gEfiAcpiTableGuid
+  gEfiXenInfoGuid
+
+[Protocols]
+  gEfiAcpiTableProtocolGuid                     # PROTOCOL ALWAYS_CONSUMED
+#  gEfiDxeSmmReadyToLockProtocolGuid             # PROTOCOL ALWAYS_CONSUMED
+
+[Pcd]
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiTableStorageFile
+
+[Depex]
+  gEfiAcpiTableProtocolGuid
+
Index: OvmfPkg/Include/Library/XenLib.h
===================================================================
--- OvmfPkg/Include/Library/XenLib.h	(revision 0)
+++ OvmfPkg/Include/Library/XenLib.h	(revision 0)
@@ -0,0 +1,376 @@
+/** @file
+
+  XEN_HV_PROTOCOL protocol allows consumers to log SMBIOS data records, and enables the producer 
+  to create the SMBIOS tables for a platform.
+
+  Copyright (c) 2006 - 2008, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials                          
+  are licensed and made available under the terms and conditions of the BSD License         
+  which accompanies this distribution.  The full text of the license may be found at        
+  http://opensource.org/licenses/bsd-license.php                                            
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,                     
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.             
+
+**/
+
+#ifndef __XEN_LIB__
+#define __XEN_LIB__
+
+/**
+  All Xen PV driver need struct and methods are defined here.
+
+**/
+
+///
+/// Guest OS interface to Xen.
+///
+#define DOMID_FIRST_RESERVED (0x7FF0U)
+#define DOMID_SELF           (0x7FF0U)
+#define DOMID_IO             (0x7FF1U)
+#define DOMID_XEN            (0x7FF2U)
+#define DOMID_COW            (0x7FF3U)
+#define DOMID_INVALID        (0x7FF4U)
+#define DOMID_IDLE           (0x7FFFU)
+
+///
+/// For HVM-guest Xenbus implementation.
+///
+#define HVM_PARAM_STORE_PFN    1
+#define HVM_PARAM_STORE_EVTCHN 2
+
+
+///
+/// For Xen Version Hypercall
+///
+#define XENVER_VERSION         0
+#define XENVER_EXTRAVERSION    1
+typedef CHAR8 XenExtraversion[16];
+
+
+//
+// For HVM Hypercall (HYPERVISOR_HVM_OP)
+//
+#define HVMOP_SET_PARAM        0
+#define HVMOP_GET_PARAM        1
+typedef UINT16 DOMID;
+typedef struct {
+  DOMID             DomId;
+  UINT32            Index;
+  UINTN             Value;
+} EFI_XEN_HVM_PARAM;
+
+
+//
+// For Sched Hypercall (HYPERVISOR_SCHED_OP)
+//
+#define SCHEDOP_POLL           3
+typedef struct {
+  UINT32           *Ptr;
+} XEN_GUEST_HANDLE;
+
+typedef struct {
+  XEN_GUEST_HANDLE  Ports;
+  UINT32            NrPorts;
+  UINTN             Timeout;
+} SCHED_POLL;
+
+
+//
+// For Memory Hypercall (HYPERVISOR_MEMORY_OP)
+//
+typedef UINTN    XEN_PFN;
+
+#define XENMEM_ADD_TO_PHYSMAP          7
+#define XENMAPSPACE_SHARED_INFO        0
+#define XENMAPSPACE_GRANT_TABLE        1
+#define XENMAPSPACE_Gmfn               2
+#define XENMAPIDX_GRANT_TABLE_STATUS   0x80000000
+typedef struct {
+  //
+  // Which domain to change the mapping for.
+  //
+  DOMID          DomId;
+  //
+  // Source mapping space.
+  //
+  UINT32         Space;
+  //
+  // Index into source mapping space.
+  //
+  UINTN          Index;
+  //
+  // GPFN (Guset Page Frame Number) where the source mapping page should appear.
+  //
+  XEN_PFN        Gpfn;
+} XEN_ADD_TO_PHYSMAP;
+
+
+
+///
+/// Event Channel stuff
+///
+typedef UINT32 EFI_EVENT_CHANNEL_PORT;
+
+//
+// Send an event to the remote end of the channel whose local endpoint is Port.
+//
+#define EVTCHNOP_SEND         4
+typedef struct {
+  EFI_EVENT_CHANNEL_PORT  Port;
+} EVENT_CHANNEL_SEND;
+
+
+
+///
+/// Xenbus stuff
+///
+
+//
+// Xen Store socket message type between Xen Store Daemon and client library or Guest VM.
+//
+typedef enum {
+  XSDebug,
+  XSDirectory,
+  XSRead,
+  XSGetPerms,
+  XSWatch,
+  XSUnwatch,
+  XSTransactionStart,
+  XSTransactionEnd,
+  XSIntroduce,
+  XSRelease,
+  XSGetDomainPath,
+  XSWrite,
+  XSMkdir,
+  XSRm,
+  XSSetPerms,
+  XSWatchEvent,
+  XSError,
+  XSIsDomainIntroduced,
+  XSResume,
+  XSSetTarget,
+  XSRestrict
+} EFI_XENSTORE_MSG_TYPE;
+
+//
+// Xen Store message struct 
+//
+typedef struct {
+  //
+  // Xen Store socket message type
+  //
+  EFI_XENSTORE_MSG_TYPE    Type;
+  //
+  // Request identifier
+  //
+  UINT32                   RequestId;
+  //
+  // Transaction id. If don't use transactions, just set 0.
+  //
+  UINT32                   TransactionId;
+  //
+  // Length of data following this
+  //
+  UINT32                   Length;
+} EFI_XENSTORE_MSG;
+
+//
+// Xen Store request
+//
+typedef struct {
+  CHAR8                    *Data;
+  UINTN                    Length;
+} EFI_XENSTORE_REQUEST;
+
+//
+// Inter-domain shared memory communications.
+//
+#define XENSTORE_RING_SIZE 1024
+typedef UINT32 XENSTORE_RING_IDX;
+typedef struct {
+  //
+  // Requests to Xenstore daemon.
+  //
+  CHAR8               Req[XENSTORE_RING_SIZE];
+  //
+  // Replies from Xenstore daemon.
+  //
+  CHAR8               Rsp[XENSTORE_RING_SIZE];
+
+  XENSTORE_RING_IDX   ReqCons;
+  XENSTORE_RING_IDX   ReqProd;
+  XENSTORE_RING_IDX   RspCons;
+  XENSTORE_RING_IDX   RspProd;
+} EFI_XENSTORE_DOMAIN_INTERFACE;
+
+#define XENSTORE_PAYLOAD_MAX  4096
+
+/**
+  Connect to the backend Xenbus daemon. 
+  This method must be called first before any Xenbus operation.
+
+  @return              EFI_STATUS.
+
+**/
+EFI_STATUS
+EFIAPI
+XenbusSetup (
+  VOID
+  );
+
+/**
+  Reset the Xenbus connection.
+
+  @return              EFI_STATUS.
+
+**/
+EFI_STATUS
+EFIAPI
+XenbusShutdown (
+  VOID
+  );
+
+/** 
+  Read a Xenstore key. Returns a nul-terminated string or NULL.
+
+  @param IN Path       The Xenstore key path.
+  @param IN Buffer     The value to assgin to the key.
+
+  @return              EFI_STATUS.
+
+**/
+EFI_STATUS
+EFIAPI
+XenstoreRead (
+  IN     CHAR8                    *Path,
+  OUT    CHAR8                    **Buffer
+  );
+
+/** 
+  Write a key-value pair in Xenstore.
+
+  @param IN Path       The Xenstore key path.
+  @param IN Buffer     The value to assgin to the key.
+
+  @return              EFI_STATUS.
+
+**/
+EFI_STATUS
+EFIAPI
+XenstoreWrite (
+  IN     CHAR8                    *Path,
+  IN     CHAR8                    *Buffer
+  );
+
+
+///
+/// Common functions used by Xen PV mechanism
+///
+
+//
+// Maximum number of virtual CPUs in multi-processor guests.
+//
+#define XEN_LEGACY_MAX_VCPUS 32
+
+typedef struct {
+  //
+  // Max PFN (Physical Frame Number).
+  //
+  UINTN                 MaxPfn;
+  //
+  // Frame containing list of mfns containing list of mfns containing p2m.
+  //
+  XEN_PFN               P2MFrameListList;
+
+  UINTN                 NmiReason;
+  UINT64                Pad[32];
+} ARCH_SHARED_INFO;
+
+//
+// TODO layout this struct for different platform (IA32 and X64).
+//
+typedef struct {
+  UINTN                 CR2;
+  //UINTN                 Pad[5];  //For Ia32
+  UINTN                 Pad;       //For X64
+} ARCH_VCPU_INFO;
+
+typedef struct {
+  UINT32                Version;
+  UINT32                Pad0;
+  //
+  // TSC time at last update of time value.
+  //
+  UINT64                TscTimestamp;
+  //
+  // Time, in nanosecs, since boot.
+  //
+  UINT64                SystemTime;
+  //
+  // Current system time.
+  //
+  UINT32                TscToSystemMul;
+  INT8                  TscShift;
+  INT8                  Pad1[3];
+} VCPU_TIME_INFO;
+
+typedef struct {
+  UINT8                 EvtChnUpcallPending;
+  UINT8                 EvtChnUpcallMask;
+  UINTN                 EvtChnPendingSel;
+  
+  ARCH_VCPU_INFO        Arch;
+  VCPU_TIME_INFO        Time;
+} VCPU_INFO;
+
+//
+// EFI_XEN_SHARED_INFO: Xen shared_info_page
+//
+typedef struct {
+  VCPU_INFO             VcpuInfo[XEN_LEGACY_MAX_VCPUS];
+  //
+  // Each channel is associated with two bits of information: PENDING and MASK.
+  //
+  UINTN                 EventChannelPending[sizeof (UINTN) * 8];
+  UINTN                 EventChannelMask[sizeof (UINTN) * 8];
+  //
+  // Wallclock time.
+  //
+  UINT32                WallClockVersion;
+  UINT32                WallClockSecond;
+  UINT32                WallClockNanosecond;
+
+  ARCH_SHARED_INFO      Arch;
+} EFI_XEN_SHARED_INFO;
+
+/**
+  Get shared info page.
+
+  @return A pointer to shared info page.
+
+**/
+VOID *
+EFIAPI
+GetSharedInfo (
+  VOID
+  );
+
+/**
+  Test and clear one bit at a gavin address.
+
+  @param IN BitNum   The number of bit to operate.
+  @param IN Addr     The address to operate.
+
+  @return  The old value of the bit.
+
+**/
+UINTN
+EFIAPI
+SyncTestClearBit (
+  IN     UINTN                    BitNum,
+  IN     VOID                     *Addr
+  );
+
+#endif //__XEN_LIB__
+
Index: OvmfPkg/Include/Library/XenHypercallLib.h
===================================================================
--- OvmfPkg/Include/Library/XenHypercallLib.h	(revision 0)
+++ OvmfPkg/Include/Library/XenHypercallLib.h	(revision 0)
@@ -0,0 +1,516 @@
+/** @file
+
+  This library provides consumers all Xen Hypercall.
+
+  Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+
+  This program and the accompanying materials                          
+  are licensed and made available under the terms and conditions of the BSD License         
+  which accompanies this distribution.  The full text of the license may be found at        
+  http://opensource.org/licenses/bsd-license.php                                            
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,                     
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.             
+
+**/
+
+#ifndef __XEN_HYPERCALL_LIB__
+#define __XEN_HYPERCALL_LIB__
+
+//
+// HYPERCALLS NUMBER
+//
+#define HYPERVISOR_SET_TRAP_TABLE          0//
+#define HYPERVISOR_MMU_UPDATE              1//
+#define HYPERVISOR_SET_GDT                 2//
+#define HYPERVISOR_STACK_SWITCH            3//
+#define HYPERVISOR_SET_CALLBACKS           4//
+#define HYPERVISOR_FPU_TASKSWITCH          5//
+#define HYPERVISOR_SCHED_OP_COMPAT         6
+#define HYPERVISOR_PLATFORM_OP             7
+#define HYPERVISOR_SET_DEBUGREG            8//
+#define HYPERVISOR_GET_DEBUGREG            9//
+#define HYPERVISOR_UPDATE_DESCRIPTOR       10//
+#define HYPERVISOR_MEMORY_OP               12   //
+#define HYPERVISOR_MULTICALL               13//
+#define HYPERVISOR_UPDATE_VA_MAPPING       14//
+#define HYPERVISOR_SET_TIMER_OP            15//
+#define HYPERVISOR_EVENT_CHANNEL_OP_COMPAT 16
+#define HYPERVISOR_XEN_VERSION             17   //
+#define HYPERVISOR_CONSOLE_IO              18//
+#define HYPERVISOR_PHYSDEV_OP_COMPAT       19
+#define HYPERVISOR_GRANT_TABLE_OP          20   //
+#define HYPERVISOR_VM_ASSIST               21//
+#define HYPERVISOR_UPDATE_VA_MAPPING_OTHERDOMAIN 22//
+#define HYPERVISOR_IRET                    23
+#define HYPERVISOR_VCPU_OP                 24//
+#define HYPERVISOR_SET_SEGMENT_BASE        25//
+#define HYPERVISOR_MMUEXT_OP               26//
+#define HYPERVISOR_XSM_OP                  27
+#define HYPERVISOR_NMI_OP                  28//
+#define HYPERVISOR_SCHED_OP                29   //
+#define HYPERVISOR_CALLBACK_OP             30
+#define HYPERVISOR_XENOPROF_OP             31
+#define HYPERVISOR_EVENT_CHANNEL_OP        32   //
+#define HYPERVISOR_PHYSDEV_OP              33//
+#define HYPERVISOR_HVM_OP                  34   //
+#define HYPERVISOR_SYSCTL                  35//
+#define HYPERVISOR_DOMCTL                  36//
+#define HYPERVISOR_KEXEC_OP                37
+#define HYPERVISOR_TMEM_OP                 38
+
+#define HYPERVISOR_ARCH_0                  48
+#define HYPERVISOR_ARCH_1                  49
+#define HYPERVISOR_ARCH_2                  50
+#define HYPERVISOR_ARCH_3                  51
+#define HYPERVISOR_ARCH_4                  52
+#define HYPERVISOR_ARCH_5                  53
+#define HYPERVISOR_ARCH_6                  54
+#define HYPERVISOR_ARCH_7                  55
+
+/**
+  Hypercall methods.
+
+  @param[in]    TODO parameters description
+  @param[in]    TODO parameters description
+
+**/
+/**
+  Hypercall #0: HYPERVISOR_SET_TRAP_TABLE
+**/
+EFI_STATUS
+EFIAPI
+HypervisorSetTrapTable (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #1: HYPERVISOR_MMU_UPDATE
+**/
+EFI_STATUS
+EFIAPI
+HypervisorMmuUpdate (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #2: HYPERVISOR_SET_GDT
+**/
+EFI_STATUS
+EFIAPI
+HypervisorSetGdt (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #3: HYPERVISOR_STACK_SWITCH
+**/
+EFI_STATUS
+EFIAPI
+HypervisorStackSwitch (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #4: HYPERVISOR_SET_CALLBACKS
+**/
+EFI_STATUS
+EFIAPI
+HypervisorSetCallbacks (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #5: HYPERVISOR_FPU_TASKSWITCH
+**/
+EFI_STATUS
+EFIAPI
+HypervisorFpuTaskswitch (
+  IN UINTN      Cmd
+  );
+
+/**
+  Hypercall #6: HYPERVISOR_SCHED_OP_COMPAT
+**/
+EFI_STATUS
+EFIAPI
+HypervisorSchedOpCompat (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #7: HYPERVISOR_PLATFORM_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorPlatformOp (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #8: HYPERVISOR_SET_DEBUGREG
+**/
+EFI_STATUS
+EFIAPI
+HypervisorSetDebugreg (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #9: HYPERVISOR_GET_DEBUGREG
+**/
+EFI_STATUS
+EFIAPI
+HypervisorGetDebugreg (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #10: HYPERVISOR_UPDATE_DESCRIPTOR
+**/
+EFI_STATUS
+EFIAPI
+HypervisorUpdateDescriptor (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #12: HYPERVISOR_MEMORY_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorMemoryOp (
+  IN UINTN      Cmd,
+  IN VOID       *Arg
+  );
+
+/**
+  Hypercall #13: HYPERVISOR_MULTICALL
+**/
+EFI_STATUS
+EFIAPI
+HypervisorMulticall (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #14: HYPERVISOR_UPDATE_VA_MAPPING
+**/
+EFI_STATUS
+EFIAPI
+HypervisorUpdateVaMapping (
+  //TODO Add parameters
+  );
+
+
+/**
+  Hypercall #15: HYPERVISOR_SET_TIMER_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorSetTimerOp (
+  //TODO Add parameters
+  );
+
+
+/**
+  Hypercall #16: HYPERVISOR_EVENT_CHANNEL_OP_COMPAT
+**/
+EFI_STATUS
+EFIAPI
+HypervisorEventChannelOpCompat (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #17: HYPERVISOR_XEN_VERSION
+**/
+EFI_STATUS
+EFIAPI
+HypervisorXenVersion (
+  IN UINTN Cmd,
+  IN VOID  *Arg
+  );
+
+/**
+  Hypercall #18: HYPERVISOR_CONSOLE_IO
+**/
+EFI_STATUS
+EFIAPI
+HypervisorConsoleIo (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #19: HYPERVISOR_PHYSDEV_OP_COMPAT
+**/
+EFI_STATUS
+EFIAPI
+HypervisorPhysdevOpCompat (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #20: HYPERVISOR_GRANT_TABLE_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorGrantTableOp(
+  IN UINTN      Cmd,
+  IN VOID       *Uop,
+  IN UINTN      Count
+);
+
+/**
+  Hypercall #21: HYPERVISOR_VM_ASSIST
+**/
+EFI_STATUS
+EFIAPI
+HypervisorVmAssist (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #22: HYPERVISOR_UPDATE_VA_MAPPING_OTHERDOMAIN
+**/
+EFI_STATUS
+EFIAPI
+HypervisorUpdateVaMappingOtherdomain (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #23: HYPERVISOR_IRET
+**/
+EFI_STATUS
+EFIAPI
+HypervisorIret (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #24: HYPERVISOR_VCPU_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorVcpuOp (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #25: HYPERVISOR_SET_SEGMENT_BASE
+**/
+EFI_STATUS
+EFIAPI
+HypervisorSetSegmentBase (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #26: HYPERVISOR_MMUEXT_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorMmuextOp (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #27: HYPERVISOR_XSM_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorXsmOp (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #28: HYPERVISOR_NMI_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorNmiOp (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #29: HYPERVISOR_SCHED_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorSchedOp (
+  IN UINTN      Cmd,
+  IN VOID       *Arg
+  );
+
+/**
+  Hypercall #30: HYPERVISOR_CALLBACK_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorCallbackOp (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #31: HYPERVISOR_XENOPROF_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorXenoprofOp (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #32: HYPERVISOR_EVENT_CHANNEL_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorEventChannelOp (
+  IN UINTN Cmd,
+  IN VOID  *Arg
+  );
+
+/**
+  Hypercall #33: HYPERVISOR_PHYSDEV_OP 
+**/
+EFI_STATUS
+EFIAPI
+HypervisorPhysdevOp (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #34: HYPERVISOR_HVM_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorHvmOp (
+  IN UINTN Cmd,
+  IN VOID  *Arg
+  );
+
+/**
+  Hypercall #35: HYPERVISOR_SYSCTL
+**/
+EFI_STATUS
+EFIAPI
+HypervisorSysctl (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #36: HYPERVISOR_DOMCTL
+**/
+EFI_STATUS
+EFIAPI
+HypervisorDomctl (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #37: HYPERVISOR_KEXEC_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorKexecOp (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #38: HYPERVISOR_TMEM_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorTmemOp (
+  //TODO Add parameters
+  );
+
+//
+// Architecture-specific hypercall definitions.
+//
+/**
+  Hypercall #48: HYPERVISOR_ARCH_0
+**/
+EFI_STATUS
+EFIAPI
+HypervisorArch0 (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #49: HYPERVISOR_ARCH_1
+**/
+EFI_STATUS
+EFIAPI
+HypervisorArch1 (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #50: HYPERVISOR_ARCH_2
+**/
+EFI_STATUS
+EFIAPI
+HypervisorArch2 (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #51: HYPERVISOR_ARCH_3
+**/
+EFI_STATUS
+EFIAPI
+HypervisorArch3 (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #52: HYPERVISOR_ARCH_4
+**/
+EFI_STATUS
+EFIAPI
+HypervisorArch4 (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #53: HYPERVISOR_ARCH_5
+**/
+EFI_STATUS
+EFIAPI
+HypervisorArch5 (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #54: HYPERVISOR_ARCH_6
+**/
+EFI_STATUS
+EFIAPI
+HypervisorArch6 (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #55: HYPERVISOR_ARCH_7
+**/
+EFI_STATUS
+EFIAPI
+HypervisorArch7 (
+  //TODO Add parameters
+  );
+
+/**
+  Initialize the hypercalls: Get Xen Hypercall page from HOB.
+  
+  @param[out]   A pointer to hypercall page.
+
+**/
+VOID *
+InitializeHypercallPage (
+  VOID
+  );
+
+#endif  //__XEN_HYPERCALL_LIB__
+
Index: OvmfPkg/OvmfPkgX64.dsc
===================================================================
--- OvmfPkg/OvmfPkgX64.dsc	(revision 12124)
+++ OvmfPkg/OvmfPkgX64.dsc	(working copy)
@@ -79,6 +79,8 @@
   UefiApplicationEntryPoint|MdePkg/Library/UefiApplicationEntryPoint/UefiApplicationEntryPoint.inf
   DevicePathLib|MdePkg/Library/UefiDevicePathLib/UefiDevicePathLib.inf
   NvVarsFileLib|OvmfPkg/Library/NvVarsFileLib/NvVarsFileLib.inf
+  XenHypercallLib|OvmfPkg/Library/XenHypercallLib/XenHypercallLib.inf
+  XenLib|OvmfPkg/Library/XenLib/XenLib.inf
   FileHandleLib|ShellPkg/Library/UefiFileHandleLib/UefiFileHandleLib.inf
   UefiCpuLib|UefiCpuPkg/Library/BaseUefiCpuLib/BaseUefiCpuLib.inf
   SecurityManagementLib|MdeModulePkg/Library/DxeSecurityManagementLib/DxeSecurityManagementLib.inf
@@ -300,9 +302,12 @@
   }
 
   MdeModulePkg/Core/RuntimeDxe/RuntimeDxe.inf
+  #
+  # Xen PV Library Test
+  #
+  OvmfPkg/HypercallTestDxe/HypercallTestDxe.inf
   MdeModulePkg/Universal/SecurityStubDxe/SecurityStubDxe.inf
   MdeModulePkg/Universal/EbcDxe/EbcDxe.inf
-  MdeModulePkg/Universal/SmbiosDxe/SmbiosDxe.inf
   PcAtChipsetPkg/8259InterruptControllerDxe/8259.inf
   UefiCpuPkg/CpuIo2Dxe/CpuIo2Dxe.inf
   UefiCpuPkg/CpuDxe/CpuDxe.inf
@@ -367,6 +372,12 @@
   IntelFrameworkModulePkg/Bus/Isa/IsaFloppyDxe/IsaFloppyDxe.inf
 
   #
+  # SMBIOS Support
+  #
+  MdeModulePkg/Universal/SmbiosDxe/SmbiosDxe.inf
+  OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.inf
+
+  #
   # ACPI Support
   #
   MdeModulePkg/Universal/Acpi/AcpiTableDxe/AcpiTableDxe.inf
Index: OvmfPkg/HypercallTestDxe/HypercallTestDxe.inf
===================================================================
--- OvmfPkg/HypercallTestDxe/HypercallTestDxe.inf	(revision 0)
+++ OvmfPkg/HypercallTestDxe/HypercallTestDxe.inf	(revision 0)
@@ -0,0 +1,52 @@
+## @file
+#  Xen PV test.
+#
+#  Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+#
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution. The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = HypercallTestDxe
+  FILE_GUID                      = 9169e45e-5db7-4b5c-9d1e-016fec787c2c
+  MODULE_TYPE                    = DXE_DRIVER
+  VERSION_STRING                 = 1.0
+
+  ENTRY_POINT                    = XenParaVirtualizationTestEntry
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64 IPF EBC
+#
+
+[Sources]
+  HypercallTestDxe.h
+  HypercallTestDxe.c
+
+[Packages]
+  MdePkg/MdePkg.dec
+  OvmfPkg/OvmfPkg.dec
+
+[LibraryClasses]
+  UefiDriverEntryPoint
+  UefiBootServicesTableLib
+  XenHypercallLib
+  XenLib
+  DebugLib
+  HobLib
+  BaseLib
+
+[Guids]
+  gEfiXenInfoGuid
+
+[Depex]
+  TRUE
Index: OvmfPkg/HypercallTestDxe/HypercallTestDxe.c
===================================================================
--- OvmfPkg/HypercallTestDxe/HypercallTestDxe.c	(revision 0)
+++ OvmfPkg/HypercallTestDxe/HypercallTestDxe.c	(revision 0)
@@ -0,0 +1,157 @@
+/** @file
+  Xen PV test Dxe.
+
+  Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+
+  This program and the accompanying materials                          
+  are licensed and made available under the terms and conditions of the BSD License         
+  which accompanies this distribution.  The full text of the license may be found at        
+  http://opensource.org/licenses/bsd-license.php                                            
+                                                                                          
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,                     
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.             
+
+**/
+
+#include "HypercallTestDxe.h"
+
+/**
+  Helper functions: print a string. (For Hypercall test)
+**/
+UINTN
+EFIAPI
+PrintAsciiStr (
+  IN      CONST CHAR8               *FirstString,
+  IN      UINTN                     Length
+  )
+{
+  ASSERT (AsciiStrSize (FirstString));
+
+  while ((*FirstString != '\0') && (Length > 0)) {
+    DEBUG ((EFI_D_INFO, "%c", *FirstString));
+    FirstString++;
+    Length--;
+  }
+
+  DEBUG ((EFI_D_INFO, "\n"));
+  return EFI_SUCCESS;
+}
+
+
+/**
+  Test Xen Hypercall. You can use hypercall in this function.
+
+**/
+EFI_STATUS
+EFIAPI
+HypercallTestFunc (
+  VOID
+  )
+{
+  EFI_STATUS         Status;
+  UINT32             Major, Minor;
+  XenExtraversion    ExtraVersion;
+
+  Major = 0; Minor = 0;
+  Minor = HypervisorXenVersion(XENVER_VERSION, 0);
+  Major = Minor >> 16;
+  Minor &= 0xFFFF;
+  DEBUG ((EFI_D_INFO, "[TestInfo_CallHypercallFromDXE]OVMF is running on Xen version: %d.%d\n", Major, Minor));
+
+  Status = HypervisorXenVersion(XENVER_EXTRAVERSION, ExtraVersion);
+  ASSERT_EFI_ERROR (Status);
+  DEBUG ((EFI_D_INFO, "[TestInfo_CallHypercallFromDXE]Detected Xen"));
+  PrintAsciiStr(ExtraVersion, 16);
+
+  return EFI_SUCCESS;
+}
+
+/**
+  Test XenBus: Read and write a key-value pair in Xenstore.
+
+**/
+EFI_STATUS
+EFIAPI
+XenbusTestFunc (
+  VOID
+  )
+{
+  //
+  // Pointer to the value of "hvmloader/bios" in Xenstore.
+  //
+  CHAR8            *XenstoreValue;
+
+  //
+  // Set Xenbus.
+  //
+  XenbusSetup ();
+
+  //
+  // Read the value of a key from xenstore.
+  //
+  XenstoreValue = NULL;
+  XenstoreRead ("hvmloader/bios", &XenstoreValue);
+  DEBUG ((EFI_D_INFO, "[TestInfo_Xenbus_ReadXenstore] Old HVM BIOS (hvmloader/bios): "));
+  PrintAsciiStr(XenstoreValue, 30);
+
+  //
+  // Modify the value of a key in xenstore.
+  // TODO modify failed!!
+  //
+  XenstoreWrite ("hvmloader/bios", "ovmf-pv-test");
+  DEBUG ((EFI_D_INFO, "[TestInfo_Xenbus_WriteXenstore] Write to Xenstore\n"));
+  XenstoreRead ("hvmloader/bios", &XenstoreValue);
+  DEBUG ((EFI_D_INFO, "[TestInfo_Xenbus_WriteXenstore] New HVM BIOS (hvmloader/bios): "));
+  PrintAsciiStr(XenstoreValue, 30);
+
+  //
+  // Clear the Xenbus.
+  //
+  XenbusShutdown();
+
+  return EFI_SUCCESS;
+}
+
+/**
+  Stub Dxe.
+
+  @param ImageHandle     Module's image handle
+  @param SystemTable     Pointer of EFI_SYSTEM_TABLE
+
+  @retval EFI_SUCCESS    Smbios protocol installed
+  @retval Other          No protocol installed, unload driver.
+
+**/
+EFI_STATUS
+EFIAPI
+XenParaVirtualizationTestEntry (
+  IN EFI_HANDLE           ImageHandle,
+  IN EFI_SYSTEM_TABLE     *SystemTable
+  )
+{
+  VOID *HypercallPages;
+
+  //
+  // Test if we can use Xen Hypercalls.
+  //
+  HypercallPages = InitializeHypercallPage ();
+  if (HypercallPages == NULL) {
+    DEBUG ((EFI_D_ERROR, "Can't find HVM hypercall page!\n"));
+    return 0;
+  }
+ 
+  //
+  // Test Xen Hypercall.
+  //
+  HypercallTestFunc();
+
+  //
+  // Test Xenbus.
+  // Read or Write a key-value in xenstore
+  //
+  XenbusTestFunc();
+
+
+  return EFI_SUCCESS;
+}
+
Index: OvmfPkg/HypercallTestDxe/HypercallTestDxe.h
===================================================================
--- OvmfPkg/HypercallTestDxe/HypercallTestDxe.h	(revision 0)
+++ OvmfPkg/HypercallTestDxe/HypercallTestDxe.h	(revision 0)
@@ -0,0 +1,31 @@
+/** @file
+  Xen PV test Dxe.
+
+  Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+
+  This program and the accompanying materials                          
+  are licensed and made available under the terms and conditions of the BSD License         
+  which accompanies this distribution.  The full text of the license may be found at        
+  http://opensource.org/licenses/bsd-license.php                                            
+                                                                                          
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,                     
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.             
+
+**/
+
+#ifndef _HYPERCALL_TEST_DXE_H_
+#define _HYPERCALL_TEST_DXE_H_
+
+#include <PiDxe.h>
+
+#include <Library/XenHypercallLib.h>
+#include <Library/XenLib.h>
+#include <Library/HobLib.h>
+#include <Library/DebugLib.h>
+#include <Library/UefiBootServicesTableLib.h>
+#include <Library/UefiDriverEntryPoint.h>
+#include <Library/BaseLib.h>
+#include <Guid/XenInfo.h>
+
+#endif
+
Index: OvmfPkg/OvmfPkgIa32.fdf
===================================================================
--- OvmfPkg/OvmfPkgIa32.fdf	(revision 12124)
+++ OvmfPkg/OvmfPkgIa32.fdf	(working copy)
@@ -150,9 +150,12 @@
 INF  MdeModulePkg/Universal/PCD/Dxe/Pcd.inf
 
 INF  MdeModulePkg/Core/RuntimeDxe/RuntimeDxe.inf
+#
+# Xen PV Library Test
+#
+INF  OvmfPkg/HypercallTestDxe/HypercallTestDxe.inf
 INF  MdeModulePkg/Universal/SecurityStubDxe/SecurityStubDxe.inf
 INF  MdeModulePkg/Universal/EbcDxe/EbcDxe.inf
-INF  MdeModulePkg/Universal/SmbiosDxe/SmbiosDxe.inf
 INF  PcAtChipsetPkg/8259InterruptControllerDxe/8259.inf
 INF  UefiCpuPkg/CpuIo2Dxe/CpuIo2Dxe.inf
 INF  UefiCpuPkg/CpuDxe/CpuDxe.inf
@@ -198,6 +201,9 @@
 INF  IntelFrameworkModulePkg/Bus/Isa/Ps2KeyboardDxe/Ps2keyboardDxe.inf
 INF  IntelFrameworkModulePkg/Bus/Isa/IsaFloppyDxe/IsaFloppyDxe.inf
 
+INF  MdeModulePkg/Universal/SmbiosDxe/SmbiosDxe.inf
+INF  OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.inf
+
 INF  MdeModulePkg/Universal/Acpi/AcpiTableDxe/AcpiTableDxe.inf
 INF  MdeModulePkg/Universal/Acpi/AcpiPlatformDxe/AcpiPlatformDxe.inf
 INF  RuleOverride=ACPITABLE OvmfPkg/AcpiTables/AcpiTables.inf
Index: OvmfPkg/OvmfPkgIa32X64.fdf
===================================================================
--- OvmfPkg/OvmfPkgIa32X64.fdf	(revision 12124)
+++ OvmfPkg/OvmfPkgIa32X64.fdf	(working copy)
@@ -152,7 +152,6 @@
 INF  MdeModulePkg/Core/RuntimeDxe/RuntimeDxe.inf
 INF  MdeModulePkg/Universal/SecurityStubDxe/SecurityStubDxe.inf
 INF  MdeModulePkg/Universal/EbcDxe/EbcDxe.inf
-INF  MdeModulePkg/Universal/SmbiosDxe/SmbiosDxe.inf
 INF  PcAtChipsetPkg/8259InterruptControllerDxe/8259.inf
 INF  UefiCpuPkg/CpuIo2Dxe/CpuIo2Dxe.inf
 INF  UefiCpuPkg/CpuDxe/CpuDxe.inf
@@ -198,6 +197,9 @@
 INF  IntelFrameworkModulePkg/Bus/Isa/Ps2KeyboardDxe/Ps2keyboardDxe.inf
 INF  IntelFrameworkModulePkg/Bus/Isa/IsaFloppyDxe/IsaFloppyDxe.inf
 
+INF  MdeModulePkg/Universal/SmbiosDxe/SmbiosDxe.inf
+INF  OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.inf
+
 INF  MdeModulePkg/Universal/Acpi/AcpiTableDxe/AcpiTableDxe.inf
 INF  MdeModulePkg/Universal/Acpi/AcpiPlatformDxe/AcpiPlatformDxe.inf
 INF  RuleOverride=ACPITABLE OvmfPkg/AcpiTables/AcpiTables.inf
Index: OvmfPkg/OvmfPkgIa32.dsc
===================================================================
--- OvmfPkg/OvmfPkgIa32.dsc	(revision 12124)
+++ OvmfPkg/OvmfPkgIa32.dsc	(working copy)
@@ -79,6 +79,8 @@
   UefiApplicationEntryPoint|MdePkg/Library/UefiApplicationEntryPoint/UefiApplicationEntryPoint.inf
   DevicePathLib|MdePkg/Library/UefiDevicePathLib/UefiDevicePathLib.inf
   NvVarsFileLib|OvmfPkg/Library/NvVarsFileLib/NvVarsFileLib.inf
+  XenHypercallLib|OvmfPkg/Library/XenHypercallLib/XenHypercallLib.inf
+  XenLib|OvmfPkg/Library/XenLib/XenLib.inf
   FileHandleLib|ShellPkg/Library/UefiFileHandleLib/UefiFileHandleLib.inf
   UefiCpuLib|UefiCpuPkg/Library/BaseUefiCpuLib/BaseUefiCpuLib.inf
   SecurityManagementLib|MdeModulePkg/Library/DxeSecurityManagementLib/DxeSecurityManagementLib.inf
@@ -300,9 +302,12 @@
   }
 
   MdeModulePkg/Core/RuntimeDxe/RuntimeDxe.inf
+  #
+  # Xen PV Library Test
+  #
+  OvmfPkg/HypercallTestDxe/HypercallTestDxe.inf
   MdeModulePkg/Universal/SecurityStubDxe/SecurityStubDxe.inf
   MdeModulePkg/Universal/EbcDxe/EbcDxe.inf
-  MdeModulePkg/Universal/SmbiosDxe/SmbiosDxe.inf
   PcAtChipsetPkg/8259InterruptControllerDxe/8259.inf
   UefiCpuPkg/CpuIo2Dxe/CpuIo2Dxe.inf
   UefiCpuPkg/CpuDxe/CpuDxe.inf
@@ -367,6 +372,12 @@
   IntelFrameworkModulePkg/Bus/Isa/IsaFloppyDxe/IsaFloppyDxe.inf
 
   #
+  # SMBIOS Support
+  #
+  MdeModulePkg/Universal/SmbiosDxe/SmbiosDxe.inf
+  OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.inf
+
+  #
   # ACPI Support
   #
   MdeModulePkg/Universal/Acpi/AcpiTableDxe/AcpiTableDxe.inf
Index: OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c
===================================================================
--- OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c	(revision 0)
+++ OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.c	(revision 0)
@@ -0,0 +1,170 @@
+/** @file
+  This driver installs SMBIOS information for OVMF
+
+  Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+  Copyright (c) 2011, Intel Corporation. All rights reserved.<BR>
+
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include "SmbiosPlatformDxe.h"
+
+
+/**
+  Validates the SMBIOS entry point structure
+
+  @param  EntryPointStructure  SMBIOS entry point structure
+
+  @retval TRUE   The entry point structure is valid
+  @retval FALSE  The entry point structure is not valid
+
+**/
+BOOLEAN
+IsEntryPointStructureValid (
+  IN SMBIOS_TABLE_ENTRY_POINT  *EntryPointStructure
+  )
+{
+  UINTN                     Index;
+  UINT8                     Length;
+  UINT8                     Checksum;
+  UINT8                     *BytePtr;
+
+  BytePtr = (UINT8*) EntryPointStructure;
+  Length = EntryPointStructure->EntryPointLength;
+  Checksum = 0;
+
+  for (Index = 0; Index < Length; Index++) {
+    Checksum += BytePtr[Index];
+  }
+
+  if (Checksum != 0) {
+    return FALSE;
+  } else {
+    return TRUE;
+  }
+}
+
+
+/**
+  Get SMBIOS record length.
+
+  @param  SmbiosTable   SMBIOS pointer.
+
+**/
+UINTN
+SmbiosTableLength (
+  IN SMBIOS_STRUCTURE_POINTER SmbiosTable
+  )
+{
+  CHAR8  *AChar;
+  UINTN  Length;
+
+  AChar = (CHAR8 *)(SmbiosTable.Raw + SmbiosTable.Hdr->Length);
+
+  //
+  // Each structure shall be terminated by a double-null (SMBIOS spec.7.1)
+  //
+  while ((*AChar != 0) || (*(AChar + 1) != 0)) {
+    AChar ++;
+  }
+  Length = ((UINTN)AChar - (UINTN)SmbiosTable.Raw + 2);
+
+  return Length;
+}
+
+
+/**
+  Install all structures from the given SMBIOS structures block
+
+  @param  Smbios               SMBIOS protocol
+  @param  EntryPointStructure  SMBIOS entry point structures block
+
+**/
+EFI_STATUS
+InstallAllStructures (
+  IN EFI_SMBIOS_PROTOCOL       *Smbios,
+  IN SMBIOS_TABLE_ENTRY_POINT  *EntryPointStructure
+  )
+{
+  EFI_STATUS                Status;
+  SMBIOS_STRUCTURE_POINTER  SmbiosTable;
+  EFI_SMBIOS_HANDLE         SmbiosHandle;
+
+  SmbiosTable.Raw = (UINT8*)(UINTN) EntryPointStructure->TableAddress;
+  if (SmbiosTable.Raw == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  while (SmbiosTable.Hdr->Type != 127) {
+    //
+    // Log the SMBIOS data for this structure
+    //
+    SmbiosHandle = 0;
+    Status = Smbios->Add (
+                       Smbios,
+                       NULL,
+                       &SmbiosHandle,
+                       (EFI_SMBIOS_TABLE_HEADER*) SmbiosTable.Raw
+                       );
+    ASSERT_EFI_ERROR (Status);
+
+    //
+    // Get the next structure address
+    //
+    SmbiosTable.Raw = (UINT8 *)(SmbiosTable.Raw + SmbiosTableLength (SmbiosTable));
+  }
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  Installs SMBIOS information for OVMF
+
+  @param ImageHandle     Module's image handle
+  @param SystemTable     Pointer of EFI_SYSTEM_TABLE
+
+  @retval EFI_SUCCESS    Smbios data successfully installed
+  @retval Other          Smbios data was not installed
+
+**/
+EFI_STATUS
+EFIAPI
+SmbiosTablePublishEntry (
+  IN EFI_HANDLE           ImageHandle,
+  IN EFI_SYSTEM_TABLE     *SystemTable
+  )
+{
+  EFI_STATUS                Status;
+  EFI_SMBIOS_PROTOCOL       *Smbios;
+  SMBIOS_TABLE_ENTRY_POINT  *EntryPointStructure;
+
+  //
+  // Find the SMBIOS protocol
+  //
+  Status = gBS->LocateProtocol (
+                  &gEfiSmbiosProtocolGuid,
+                  NULL,
+                  (VOID**)&Smbios
+                  );
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  //
+  // Add Xen SMBIOS data if found
+  //
+  EntryPointStructure = GetXenSmbiosTables ();
+  if (EntryPointStructure != NULL) {
+    Status = InstallAllStructures (Smbios, EntryPointStructure);
+  }
+
+  return Status;
+}
Index: OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.h
===================================================================
--- OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.h	(revision 0)
+++ OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.h	(revision 0)
@@ -0,0 +1,56 @@
+/** @file
+  This driver installs SMBIOS information for OVMF
+
+  Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+  Copyright (c) 2011, Intel Corporation. All rights reserved.<BR>
+
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#ifndef _SMBIOS_PLATFORM_DXE_H_
+#define _SMBIOS_PLATFORM_DXE_H_
+
+#include <PiDxe.h>
+
+#include <Protocol/Smbios.h>
+#include <IndustryStandard/SmBios.h>
+#include <Library/DebugLib.h>
+#include <Library/BaseLib.h>
+#include <Library/BaseMemoryLib.h>
+#include <Library/UefiBootServicesTableLib.h>
+
+
+/**
+  Locates the Xen SMBIOS data if it exists
+
+  @return SMBIOS_TABLE_ENTRY_POINT   Address of Xen SMBIOS data
+
+**/
+SMBIOS_TABLE_ENTRY_POINT *
+GetXenSmbiosTables (
+  VOID
+  );
+
+
+/**
+  Validates the SMBIOS entry point structure
+
+  @param  EntryPointStructure  SMBIOS entry point structure
+
+  @retval TRUE   The entry point structure is valid
+  @retval FALSE  The entry point structure is not valid
+
+**/
+BOOLEAN
+IsEntryPointStructureValid (
+  IN SMBIOS_TABLE_ENTRY_POINT  *EntryPointStructure
+  );
+
+#endif
Index: OvmfPkg/SmbiosPlatformDxe/Xen.c
===================================================================
--- OvmfPkg/SmbiosPlatformDxe/Xen.c	(revision 0)
+++ OvmfPkg/SmbiosPlatformDxe/Xen.c	(revision 0)
@@ -0,0 +1,63 @@
+/** @file
+  Detect Xen hvmloader SMBIOS data for usage by OVMF.
+
+  Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+  Copyright (c) 2011, Intel Corporation. All rights reserved.<BR>
+
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include "SmbiosPlatformDxe.h"
+#include <Library/HobLib.h>
+#include <Guid/XenInfo.h>
+
+#define XEN_SMBIOS_PHYSICAL_ADDRESS       0x000EB000
+#define XEN_SMBIOS_PHYSICAL_END           0x000F0000
+
+/**
+  Locates the Xen SMBIOS data if it exists
+
+  @return SMBIOS_TABLE_ENTRY_POINT   Address of Xen SMBIOS data
+
+**/
+SMBIOS_TABLE_ENTRY_POINT *
+GetXenSmbiosTables (
+  VOID
+  )
+{
+  UINT8                     *XenSmbiosPtr;
+  SMBIOS_TABLE_ENTRY_POINT  *XenSmbiosEntryPointStructure;
+  EFI_HOB_GUID_TYPE         *GuidHob;
+
+  //
+  // See if a XenInfo HOB is available
+  //
+  GuidHob = GetFirstGuidHob (&gEfiXenInfoGuid);
+  if (GuidHob == NULL) {
+    return NULL;
+  }
+
+  for (XenSmbiosPtr = (UINT8*) XEN_SMBIOS_PHYSICAL_ADDRESS;
+       XenSmbiosPtr < (UINT8*) XEN_SMBIOS_PHYSICAL_END;
+       XenSmbiosPtr += 0x10) {
+
+    XenSmbiosEntryPointStructure = (SMBIOS_TABLE_ENTRY_POINT *) XenSmbiosPtr;
+
+    if (!AsciiStrnCmp ((CHAR8 *) XenSmbiosEntryPointStructure->AnchorString, "_SM_", 4) &&
+        !AsciiStrnCmp ((CHAR8 *) XenSmbiosEntryPointStructure->IntermediateAnchorString, "_DMI_", 5) &&
+        IsEntryPointStructureValid (XenSmbiosEntryPointStructure)) {
+
+      return XenSmbiosEntryPointStructure;
+
+    }
+  }
+
+  return NULL;
+}
Index: OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.inf
===================================================================
--- OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.inf	(revision 0)
+++ OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.inf	(revision 0)
@@ -0,0 +1,57 @@
+## @file
+#  This driver installs SMBIOS information for OVMF
+#
+#  Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+#  Copyright (c) 2011, Intel Corporation. All rights reserved.<BR>
+#
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution. The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = SmbiosPlatformDxe
+  FILE_GUID                      = 4110465d-5ff3-4f4b-b580-24ed0d06747a
+  MODULE_TYPE                    = DXE_DRIVER
+  VERSION_STRING                 = 1.0
+
+  ENTRY_POINT                    = SmbiosTablePublishEntry
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64 IPF EBC
+#
+
+[Sources]
+  SmbiosPlatformDxe.h
+  SmbiosPlatformDxe.c
+  Xen.c
+
+[Packages]
+  MdePkg/MdePkg.dec
+  MdeModulePkg/MdeModulePkg.dec
+  OvmfPkg/OvmfPkg.dec
+
+[LibraryClasses]
+  UefiBootServicesTableLib
+  BaseMemoryLib
+  BaseLib
+  UefiDriverEntryPoint
+  DebugLib
+  HobLib
+
+[Protocols]
+  gEfiSmbiosProtocolGuid                      # PROTOCOL ALWAYS_CONSUMED
+
+[Guids]
+  gEfiXenInfoGuid
+
+[Depex]
+  gEfiSmbiosProtocolGuid
+
Index: OvmfPkg/OvmfPkgIa32X64.dsc
===================================================================
--- OvmfPkg/OvmfPkgIa32X64.dsc	(revision 12124)
+++ OvmfPkg/OvmfPkgIa32X64.dsc	(working copy)
@@ -303,7 +303,6 @@
   MdeModulePkg/Core/RuntimeDxe/RuntimeDxe.inf
   MdeModulePkg/Universal/SecurityStubDxe/SecurityStubDxe.inf
   MdeModulePkg/Universal/EbcDxe/EbcDxe.inf
-  MdeModulePkg/Universal/SmbiosDxe/SmbiosDxe.inf
   PcAtChipsetPkg/8259InterruptControllerDxe/8259.inf
   UefiCpuPkg/CpuIo2Dxe/CpuIo2Dxe.inf
   UefiCpuPkg/CpuDxe/CpuDxe.inf
@@ -368,6 +367,12 @@
   IntelFrameworkModulePkg/Bus/Isa/IsaFloppyDxe/IsaFloppyDxe.inf
 
   #
+  # SMBIOS Support
+  #
+  MdeModulePkg/Universal/SmbiosDxe/SmbiosDxe.inf
+  OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.inf
+
+  #
   # ACPI Support
   #
   MdeModulePkg/Universal/Acpi/AcpiTableDxe/AcpiTableDxe.inf
Index: OvmfPkg/Library/XenLib/XenLib.c
===================================================================
--- OvmfPkg/Library/XenLib/XenLib.c	(revision 0)
+++ OvmfPkg/Library/XenLib/XenLib.c	(revision 0)
@@ -0,0 +1,83 @@
+/**@file
+  This file holds the common functions used by xen paravirtualization.
+
+  Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include "XenLib.h"
+
+/**
+  Get shared info page.
+
+  @return A pointer to shared info page.
+
+**/
+VOID *
+EFIAPI
+GetSharedInfo (
+  VOID
+  )
+{
+  static EFI_XEN_SHARED_INFO         *SharedInfoPtr = NULL;
+  XEN_ADD_TO_PHYSMAP                 AddPhysmap;
+
+  if (SharedInfoPtr != NULL) {
+    return (VOID *) SharedInfoPtr;
+  }
+
+  AddPhysmap.DomId  = DOMID_SELF; 
+  AddPhysmap.Space  = XENMAPSPACE_SHARED_INFO;
+  AddPhysmap.Index  = 0;
+
+  SharedInfoPtr   = (EFI_XEN_SHARED_INFO *)AllocatePages(EFI_PAGE_SIZE);
+  AddPhysmap.Gpfn = (UINTN)(SharedInfoPtr) >> EFI_PAGE_SHIFT;
+
+  if (HypervisorMemoryOp(XENMEM_ADD_TO_PHYSMAP, &AddPhysmap)) {
+    DEBUG ((EFI_D_ERROR, "Hypercall Error: can't get shared info page.\n"));
+    return NULL;
+  }
+
+  DEBUG ((EFI_D_INFO, "SharedInfoPtr = %x\n", SharedInfoPtr)); 
+  return (VOID *) SharedInfoPtr;
+}
+
+/**
+  Test and clear one bit at a gavin address.
+  TODO The method needs to be written as a assembly function.
+
+  @param IN BitNum   The number of bit to operate.
+  @param IN Addr     The address to operate.
+
+  @return  The old value of the bit.
+
+**/
+UINTN
+EFIAPI
+SyncTestClearBit (
+  IN     UINTN                    BitNum,
+  IN     VOID                     *Addr
+  )
+{
+  UINTN             OldBit;
+
+  __asm__ __volatile__ (
+    "lock          \n\t"
+    "btr  %2,  %1  \n\t"
+    "sbb  %0,  %0  \n\t"
+    : "=r" (OldBit), "=m" (*(volatile long *)Addr)
+    : "Ir" (BitNum), "m" (*(volatile long *)Addr) 
+    : "memory"
+    );
+
+  return OldBit;
+}
+
Index: OvmfPkg/Library/XenLib/XenBus.c
===================================================================
--- OvmfPkg/Library/XenLib/XenBus.c	(revision 0)
+++ OvmfPkg/Library/XenLib/XenBus.c	(revision 0)
@@ -0,0 +1,471 @@
+/**@file
+  This file holds the xenbus methods, which can setup xenbus, write and read xenstore entry.
+
+  Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include "XenLib.h"
+
+//
+// Shared ring with Domain0
+//
+EFI_XENSTORE_DOMAIN_INTERFACE    *Rings = NULL;
+//
+// Event channel to Domain0
+//
+EFI_EVENT_CHANNEL_PORT            Event;
+static CHAR8                      Payload[XENSTORE_PAYLOAD_MAX + 1];
+
+
+/**
+  Helper functions: print a string.
+**/
+UINTN
+EFIAPI
+PrintStr (
+  IN      CONST CHAR8               *FirstString,
+  IN      UINTN                     Length
+  )
+{
+  ASSERT (AsciiStrSize (FirstString));
+
+  while ((*FirstString != '\0') && (Length > 0)) {
+    DEBUG ((EFI_D_INFO, "%c", *FirstString));
+    FirstString++;
+    Length--;
+  }
+
+  DEBUG ((EFI_D_INFO, "\n"));
+  return EFI_SUCCESS;
+}
+
+/**
+  Connect to the backend Xenbus daemon. 
+  This method must be called first before any Xenbus operation.
+
+  @return              EFI_STATUS.
+
+**/
+EFI_STATUS
+EFIAPI
+XenbusSetup (
+  VOID
+  )
+{
+  EFI_XEN_HVM_PARAM  Param;
+
+  //
+  // Get Xenbus shared page.
+  //
+  Param.DomId = DOMID_SELF;
+  Param.Index = HVM_PARAM_STORE_PFN;
+  if ( HypervisorHvmOp(HVMOP_GET_PARAM, &Param) ) {
+    DEBUG ((EFI_D_ERROR, "Hypercall Error: can't get xenbus shared page.\n"));
+  }
+  Rings = (VOID *)(UINTN)(Param.Value << EFI_PAGE_SHIFT);
+
+  //
+  // Get Xenbus event channel.
+  //
+  Param.DomId = DOMID_SELF;
+  Param.Index = HVM_PARAM_STORE_EVTCHN;
+  if ( HypervisorHvmOp(HVMOP_GET_PARAM, &Param) ) {
+    DEBUG ((EFI_D_ERROR, "Hypercall Error: can't get xenbus event channel.\n"));
+  }
+  Event = Param.Value;
+
+  DEBUG ((EFI_D_INFO, "Xenbus rings @0x%x, event channel %d\n", (UINTN) Rings, (UINTN) Event));
+  return EFI_SUCCESS;
+}
+
+/**
+  Reset the Xenbus connection.
+
+  @return              EFI_STATUS.
+
+**/
+EFI_STATUS
+EFIAPI
+XenbusShutdown (
+  VOID
+  )
+{
+  ASSERT(Rings);
+
+  //
+  // Clear the shared ring.
+  //
+  ZeroMem (Rings, sizeof (EFI_XENSTORE_DOMAIN_INTERFACE));  
+
+  //
+  // Clear the event channel state
+  //
+  ZeroMem(GetSharedInfo (), sizeof (EFI_XEN_SHARED_INFO));
+
+  Rings = NULL;
+  return EFI_SUCCESS;
+}
+
+/**
+  Shared Ring operation methods.
+**/
+VOID
+EFIAPI
+RingWait (
+  VOID
+  )
+{
+  EFI_XEN_SHARED_INFO      *SharedInfoPtr;
+  SCHED_POLL               Poll;
+
+  SharedInfoPtr = (EFI_XEN_SHARED_INFO *) GetSharedInfo ();
+
+  ZeroMem (&Poll, sizeof (SCHED_POLL));
+  Poll.Ports.Ptr = &Event;
+  Poll.NrPorts   = 1;
+
+  while ( !SyncTestClearBit(Event, SharedInfoPtr->EventChannelPending) ) {
+    HypervisorSchedOp (SCHEDOP_POLL, &Poll);
+  }
+}
+
+/**
+  Copy data in and out of the ring
+
+  @param IN Data      The data to write into the shared ring.
+  @param IN Length    The length of the data.
+
+**/
+VOID
+EFIAPI
+RingWrite (
+  IN     CHAR8                    *Data,
+  IN     UINTN                    Length
+  )
+{
+  UINT32           TotleOff;
+  UINT32           RingIndex;
+
+  //
+  // Check the parameters
+  //
+  ASSERT(Length <= XENSTORE_PAYLOAD_MAX);
+
+  RingIndex = XENSTORE_RING_SIZE - 1;
+  while (Length) {
+    //
+    // Keep don't overrun the consumer pointer.
+    //
+    while ((TotleOff = RingIndex - ((Rings->ReqProd - Rings->ReqCons) & RingIndex)) == 0) {
+      RingWait();
+    }
+
+    //
+    // Keep don't overrun the end of the shared ring.
+    //
+    if (TotleOff > (XENSTORE_RING_SIZE - (Rings->ReqProd & RingIndex))) {
+      TotleOff = XENSTORE_RING_SIZE - (Rings->ReqProd & RingIndex);
+    }
+
+    if (TotleOff > Length) {
+      TotleOff = Length;
+    }
+
+    //
+    // Copy the request data to the ring.
+    //
+    CopyMem (
+      Rings->Req + (Rings->ReqProd & RingIndex),
+      Data,
+      TotleOff
+      );
+    MemoryFence();
+    Rings->ReqProd += TotleOff;
+    Length -= TotleOff;
+  }
+}
+
+/**
+  Copy data in and out of the ring
+
+  @param IN Data      The data read from the shared ring.
+  @param IN Length    The length of the data.
+
+**/
+VOID
+EFIAPI
+RingRead (
+  IN     CHAR8                    *Data,
+  IN     UINTN                    Length
+  )
+{
+  UINT32           TotleOff;
+  UINT32           RingIndex;
+
+  //
+  // Check the parameters
+  //
+  ASSERT(Length <= XENSTORE_PAYLOAD_MAX);
+
+  RingIndex = XENSTORE_RING_SIZE - 1;
+  while (Length) {
+    //
+    // Keep don't overrun the productor pointer.
+    //
+    while ((TotleOff = ((Rings->RspProd - Rings->RspCons) & RingIndex)) == 0) {
+      RingWait();
+    }
+
+    //
+    // Keep don't overrun the end of the shared ring.
+    //
+    if (TotleOff > (XENSTORE_RING_SIZE - (Rings->RspCons & RingIndex))) {
+      TotleOff = XENSTORE_RING_SIZE - (Rings->RspCons & RingIndex);
+    }
+
+    if (TotleOff > Length) {
+      TotleOff = Length;
+    }
+
+    //
+    // Copy the reply data from the ring.
+    //
+    CopyMem (
+      Data,
+      Rings->Rsp + (Rings->RspCons & RingIndex),
+      TotleOff
+      );
+    MemoryFence();
+    Rings->RspCons += TotleOff;
+    Length -= TotleOff;
+  }
+}
+
+/**
+  Send a request to shared ring and wait for the answer.
+  Returns 0 for success, or an errno for error.
+
+  @param IN BitNum   The number of bit to operate.
+  @param IN Addr     The address to operate.
+
+  @return  The old value of the bit.
+
+**/
+EFI_STATUS
+EFIAPI
+XenbusSend (
+  IN     EFI_XENSTORE_MSG_TYPE    Type,
+  IN     UINTN                    Length,
+  IN     CHAR8                    *Data,
+  OUT    UINTN                    *ReplyLength,
+  OUT    CHAR8                    **ReplyData
+  )
+{
+  EFI_XENSTORE_MSG              XenstoreMsg;
+  EVENT_CHANNEL_SEND            Send;
+
+  //
+  // Check the shared ring.
+  //
+  ASSERT(Rings);
+
+  //
+  // Put the request on the shared ring.
+  //
+  XenstoreMsg.Type              = Type;
+  XenstoreMsg.RequestId         = 0;
+  XenstoreMsg.TransactionId     = 0;
+  XenstoreMsg.Length            = Length;
+
+  RingWrite ((CHAR8 *) &XenstoreMsg, sizeof (EFI_XENSTORE_MSG));
+  RingWrite (Data, Length);
+
+  //
+  // Tell Dom0 about the request.
+  //
+  Send.Port = Event;
+  HypervisorEventChannelOp(EVTCHNOP_SEND, &Send);
+
+  //
+  // Get the reply from the ring.
+  //
+  RingRead ((CHAR8 *) &XenstoreMsg, sizeof (EFI_XENSTORE_MSG));
+  RingRead (Payload, XenstoreMsg.Length);
+  Payload[XenstoreMsg.Length] = '\0';
+
+  if (XenstoreMsg.Type == XSError) {
+    *ReplyLength = 0;
+    return EFI_ABORTED;
+  }
+
+  *ReplyData    = Payload;
+  *ReplyLength  = XenstoreMsg.Length;
+
+  return EFI_SUCCESS;
+}
+
+/**
+  This method is a updated version of XenbusSend().
+  It can be used for XSWrite and XSRead.
+
+  @param IN BitNum   The number of bit to operate.
+  @param IN Addr     The address to operate.
+
+  @return  The old value of the bit.
+
+**/
+EFI_STATUS
+EFIAPI
+XenbusWriteSend (
+  IN     EFI_XENSTORE_MSG_TYPE    Type,
+  IN     CHAR8                    *Path,
+  IN     CHAR8                    *Data,
+  OUT    UINTN                    *ReplyLength,
+  OUT    CHAR8                    **ReplyData
+  )
+{
+  EFI_XENSTORE_MSG              XenstoreMsg;
+  EVENT_CHANNEL_SEND            Send;
+  EFI_XENSTORE_REQUEST          Request[2];
+  UINTN                         RequestNum;
+  UINTN                         Length;
+  UINTN                         Index;
+  
+  //
+  // Check the shared ring.
+  //
+  ASSERT(Rings);
+
+  //
+  // Initialize the request
+  //
+  if (Type == XSWrite) {
+    Request[0].Data    = Path;
+    Request[0].Length  = AsciiStrLen (Path) + 1;
+    Request[1].Data    = Data;
+    Request[1].Length  = AsciiStrLen (Data);
+    RequestNum         = 2; 
+    Length             = Request[0].Length + Request[1].Length;
+  }
+  else {
+    Request[0].Data    = Path;
+    Request[0].Length  = AsciiStrLen (Path) + 1;
+    RequestNum         = 1; 
+    Length             = Request[0].Length;
+  }
+
+  //
+  // Put the request on the shared ring.
+  //
+  XenstoreMsg.Type              = Type;
+  XenstoreMsg.RequestId         = 0;
+  XenstoreMsg.TransactionId     = 0;
+  XenstoreMsg.Length            = Length;
+
+  RingWrite ((CHAR8 *) &XenstoreMsg, sizeof (EFI_XENSTORE_MSG));
+  for (Index = 0; Index < RequestNum; Index++) {
+    RingWrite (Request[Index].Data, Request[Index].Length);
+  }
+
+  //
+  // Tell Dom0 about the request.
+  //
+  Send.Port = Event;
+  HypervisorEventChannelOp(EVTCHNOP_SEND, &Send);
+
+  //
+  // Get the reply from the ring.
+  //
+  RingRead ((CHAR8 *) &XenstoreMsg, sizeof (EFI_XENSTORE_MSG));
+  RingRead (Payload, XenstoreMsg.Length);
+  Payload[XenstoreMsg.Length] = '\0';
+
+  if (XenstoreMsg.Type == XSError) {
+    *ReplyLength = 0;
+    return EFI_ABORTED;
+  }
+
+  *ReplyData    = Payload;
+  *ReplyLength  = XenstoreMsg.Length;
+
+  return EFI_SUCCESS;
+}
+
+/** 
+  Read a Xenstore key. Returns a nul-terminated string or NULL.
+
+  @param IN Path       The Xenstore key path.
+  @param IN Buffer     The value to assgin to the key.
+
+  @return              EFI_STATUS.
+
+**/
+EFI_STATUS
+EFIAPI
+XenstoreRead (
+  IN     CHAR8                    *Path,
+  OUT    CHAR8                    **Buffer
+  )
+{
+  UINTN        Length;
+  CHAR8        *Value;
+
+  //
+  // Send request to Xen Store
+  //
+  Length = 0;
+  Value  = NULL;
+
+  if ( XenbusSend(XSRead, AsciiStrLen (Path) + 1, Path, &Length, &Value) ) {
+  //if ( XenbusWriteSend(XSRead, Path, NULL, &Length, &Value) ) {
+    return EFI_NOT_FOUND;
+  }
+
+  //
+  // Get the key value, which terminated null.
+  //
+  *Buffer = Value;
+
+  return EFI_SUCCESS;
+}
+
+/** 
+  Write a key-value pair in Xenstore.
+
+  @param IN Path       The Xenstore key path.
+  @param IN Buffer     The value to assgin to the key.
+
+  @return              EFI_STATUS.
+
+**/
+EFI_STATUS
+EFIAPI
+XenstoreWrite (
+  IN     CHAR8                    *Path,
+  IN     CHAR8                    *Buffer
+  )
+{
+  UINTN        Length;
+  CHAR8        *Value;
+
+  //
+  // Send request to Xen Store
+  //
+  Length = 0;
+  Value  = NULL;
+  if ( XenbusWriteSend(XSWrite, Path, Buffer, &Length, &Value) ) {
+    return EFI_NOT_FOUND;
+  }
+
+  return EFI_SUCCESS;
+}
+
Index: OvmfPkg/Library/XenLib/XenLib.h
===================================================================
--- OvmfPkg/Library/XenLib/XenLib.h	(revision 0)
+++ OvmfPkg/Library/XenLib/XenLib.h	(revision 0)
@@ -0,0 +1,31 @@
+/**@file
+  Xenbus library.
+
+  Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#ifndef _XEN_LIB_H_
+#define _XEN_LIB_H_
+
+#include <PiDxe.h>
+
+#include <Library/MemoryAllocationLib.h>
+#include <Library/BaseMemoryLib.h>
+#include <Library/BaseLib.h>
+#include <Library/DebugLib.h>
+#include <Guid/XenInfo.h>
+
+#include <Library/XenHypercallLib.h>
+#include <Library/XenLib.h>
+
+#endif
+
Index: OvmfPkg/Library/XenLib/XenLib.inf
===================================================================
--- OvmfPkg/Library/XenLib/XenLib.inf	(revision 0)
+++ OvmfPkg/Library/XenLib/XenLib.inf	(revision 0)
@@ -0,0 +1,44 @@
+## @file
+#  Component description file for Xenbus Library module.
+#
+#  Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution.  The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php
+#
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = XenLib
+  FILE_GUID                      = 62c85c20-5b0e-4937-9fc3-448370a60d04
+  MODULE_TYPE                    = BASE
+  VERSION_STRING                 = 1.0
+  LIBRARY_CLASS                  = XenLib|DXE_DRIVER DXE_RUNTIME_DRIVER DXE_SAL_DRIVER UEFI_DRIVER
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64 IPF
+#
+
+[Sources]
+  XenLib.h
+  XenLib.c
+  XenBus.c
+
+[Packages]
+  MdePkg/MdePkg.dec
+  OvmfPkg/OvmfPkg.dec
+
+[LibraryClasses]
+  MemoryAllocationLib
+  BaseMemoryLib
+  BaseLib
+  DebugLib
+
Index: OvmfPkg/Library/XenHypercallLib/XenHypercallLib.inf
===================================================================
--- OvmfPkg/Library/XenHypercallLib/XenHypercallLib.inf	(revision 0)
+++ OvmfPkg/Library/XenHypercallLib/XenHypercallLib.inf	(revision 0)
@@ -0,0 +1,56 @@
+## @file
+#  Component description file for Xen Hypercall Library module.
+#
+#  Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+#
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution. The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = XenHypercallLib
+  FILE_GUID                      = 0a5baf88-b6ec-4338-b1a7-f1496f605359
+  MODULE_TYPE                    = UEFI_DRIVER
+  VERSION_STRING                 = 1.0
+
+  LIBRARY_CLASS                  = XenHypercallLib|DXE_DRIVER DXE_RUNTIME_DRIVER DXE_SAL_DRIVER UEFI_DRIVER
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64 IPF EBC
+#
+
+[Sources]
+  GasketHypercall.h
+  XenHypercallLib.h
+  XenHypercallLib.c
+  Hypercall.c
+
+[Sources.X64]
+  X64/GasketHypercall.S   # convert between Emu x86_64 ABI and EFI X64 ABI
+
+[Sources.IA32]
+  Ia32/GasketHypercall.S  #
+
+
+[Packages]
+  MdePkg/MdePkg.dec
+  OvmfPkg/OvmfPkg.dec
+
+[LibraryClasses]
+  DebugLib
+  HobLib
+
+[Guids]
+  gEfiXenInfoGuid                      # PROTOCOL ALWAYS_CONSUMED
+
+[Depex]
+  TRUE
Index: OvmfPkg/Library/XenHypercallLib/X64/GasketHypercall.S
===================================================================
--- OvmfPkg/Library/XenHypercallLib/X64/GasketHypercall.S	(revision 0)
+++ OvmfPkg/Library/XenHypercallLib/X64/GasketHypercall.S	(revision 0)
@@ -0,0 +1,93 @@
+#------------------------------------------------------------------------------
+#
+# Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+#
+# This program and the accompanying materials
+# are licensed and made available under the terms and conditions of the BSD License
+# which accompanies this distribution.  The full text of the license may be found at
+# http://opensource.org/licenses/bsd-license.php.
+#
+# THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+# WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+# Module Name:
+#
+#   GasketHypercall.S
+#
+# Abstract:
+#
+#   Hypercall function
+#
+# Notes:
+#
+#------------------------------------------------------------------------------
+
+#------------------------------------------------------------------------------
+#  UINTN
+#  EFIAPI
+#  Hypercall (
+#    IN  VOID   *HypercallPageAddress,  // passed in %rcx
+#    IN  UINTN  HypercallOffset,        // passed in %rdx
+#    IN  UINTN  Arg1,                   // passed in %r8
+#    IN  UINTN  Arg2,                   // passed in %r9
+#    IN  UINTN  Arg3,                   // passed in stack
+#    IN  UINTN  Arg4,                   // passed in stack
+#    IN  UINTN  Arg5,                   // passed in stack
+#    )
+#------------------------------------------------------------------------------
+
+  .text
+
+ASM_GLOBAL ASM_PFX(Hypercall)
+ASM_PFX(Hypercall):
+  pushq   %rbp            // stack frame is for the debugger
+  movq    %rsp, %rbp
+  subq    $16, %rsp       // Allocate space for args on the stack
+
+  pushq   %rsi            // %rsi & %rdi are callee-save in EFI ABI
+  pushq   %rdi
+
+  movq    %rcx, %rax      // Swizzle args
+  addq    %rdx, %rax      // Address of hypercall is in %rax
+
+  movq    %r8,  %rdi      // Move parameters into %rdi,
+  movq    %r9,  %rsi      // %rsi,
+  movq    48(%rbp), %rdx  // %rdx,
+  movq    56(%rbp), %r10  // %r10,
+  movq    64(%rbp), %r8   // %r8
+  movq    %r8,     (%rsp) //
+
+  call    *%rax
+  addq    $16, %rsp
+
+  popq    %rdi            // restore state
+  popq    %rsi
+  popq    %rbp
+  ret                     // return value is in %rax
+
+
+//
+// Hypercall2 is not used.
+//
+ASM_GLOBAL ASM_PFX(Hypercall2)
+ASM_PFX(Hypercall2):
+  pushq   %rbp            // stack frame is for the debugger
+  movq    %rsp, %rbp
+
+  pushq   %rsi            // %rsi & %rdi are callee-save in EFI ABI
+  pushq   %rdi
+
+  movq    %rcx, %rax      // Swizzle args
+  addq    %rdx, %rax      // Address of hypercall is in %rax
+
+  movq    %r8,  %rdi      // Move parameters into %rdi, %rsi
+  movq    %r9,  %rsi
+
+  call    *%rax
+
+  popq    %rdi            // restore state
+  popq    %rsi
+  popq    %rbp
+  ret                     // return value is in %rax
+
+
Index: OvmfPkg/Library/XenHypercallLib/Hypercall.c
===================================================================
--- OvmfPkg/Library/XenHypercallLib/Hypercall.c	(revision 0)
+++ OvmfPkg/Library/XenHypercallLib/Hypercall.c	(revision 0)
@@ -0,0 +1,140 @@
+/**@file
+  This file holds all the needed Xen Hypercalls.
+
+  Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include "XenHypercallLib.h"
+
+/**
+  This method passes the hypercall parameters and hypercall number to UNIX ABI function, as well as the address of hypercall page.
+
+  @param  HypercallNum    The Number of the hypercall.
+  @param  Arg1-Arg5       Parameters for the hypercall.
+
+**/
+EFI_STATUS
+EFIAPI
+Hypercall2Abi (
+  IN  UINTN  HypercallNum,
+  IN  UINTN  Arg1,
+  IN  UINTN  Arg2,
+  IN  UINTN  Arg3,
+  IN  UINTN  Arg4,
+  IN  UINTN  Arg5
+  )
+{
+  VOID *HypercallPages;
+
+  HypercallPages = InitializeHypercallPage ();
+  if (HypercallPages == NULL) {
+    return 0;
+  }
+
+  //
+  // All the hypercalls call this function.
+  //
+  return Hypercall (HypercallPages, HypercallNum * 32, Arg1, Arg2, Arg3, Arg4, Arg5);
+}
+
+/**
+  Xen Hypercall. All the hypercalls call one function.
+
+  @param  Cmd       parameter.
+  @param  Arg       Parameter.
+
+**/
+
+/**
+  Hypercall #12: HYPERVISOR_MEMORY_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorMemoryOp (
+  IN UINTN      Cmd,
+  IN VOID       *Arg
+  )
+{
+  return Hypercall2Abi (HYPERVISOR_MEMORY_OP, (UINTN) Cmd, (UINTN) Arg, 0, 0, 0);
+}
+
+/**
+  Hypercall #17: HYPERVISOR_XEN_VERSION
+**/
+EFI_STATUS
+EFIAPI
+HypervisorXenVersion (
+  IN UINTN      Cmd,
+  IN VOID       *Arg
+  )
+{
+  return Hypercall2Abi (HYPERVISOR_XEN_VERSION, (UINTN) Cmd, (UINTN) Arg, 0, 0, 0);
+}
+
+/**
+  Hypercall #20: HYPERVISOR_GRANT_TABLE_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorGrantTableOp(
+  IN UINTN      Cmd,
+  IN VOID       *Uop,
+  IN UINTN      Count
+)
+{
+  return Hypercall2Abi (HYPERVISOR_GRANT_TABLE_OP, (UINTN) Cmd, (UINTN) Uop, Count, 0, 0);
+}
+
+/**
+  Hypercall #29: HYPERVISOR_SCHED_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorSchedOp (
+  IN UINTN      Cmd,
+  IN VOID       *Arg
+  )
+{
+  return Hypercall2Abi(HYPERVISOR_SCHED_OP, (UINTN) Cmd, (UINTN) Arg, 0, 0, 0);
+}
+
+/**
+  Hypercall #32: HYPERVISOR_EVENT_CHANNEL_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorEventChannelOp (
+  IN UINTN      Cmd,
+  IN VOID       *Arg
+  )
+{
+  return Hypercall2Abi(HYPERVISOR_EVENT_CHANNEL_OP, (UINTN) Cmd, (UINTN) Arg, 0, 0, 0);
+}
+
+/**
+  Hypercall #34: HYPERVISOR_HVM_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorHvmOp (
+  IN UINTN      Cmd,
+  IN VOID       *Arg
+  )
+{
+  return Hypercall2Abi (HYPERVISOR_HVM_OP, (UINTN) Cmd, (UINTN) Arg, 0, 0, 0);
+}
+
+/*
+  Add more hypercall here
+
+**/
+
Index: OvmfPkg/Library/XenHypercallLib/XenHypercallLib.c
===================================================================
--- OvmfPkg/Library/XenHypercallLib/XenHypercallLib.c	(revision 0)
+++ OvmfPkg/Library/XenHypercallLib/XenHypercallLib.c	(revision 0)
@@ -0,0 +1,43 @@
+/** @file
+Prepare to use Xen Hypercall.
+
+Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+
+This program and the accompanying materials
+are licensed and made available under the terms and conditions of the BSD License
+which accompanies this distribution.  The full text of the license may be found at
+http://opensource.org/licenses/bsd-license.php
+
+THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include "XenHypercallLib.h"
+
+/**
+  Initialize the hypercalls: Get Xen Hypercall page from HOB.
+  
+  @param[out]   A pointer to hypercall page.
+
+**/
+VOID *
+InitializeHypercallPage (
+  VOID
+  )
+{
+  EFI_PEI_HOB_POINTERS  GuidHob;
+  EFI_XEN_INFO          *mXenInfo;
+ 
+  GuidHob.Raw = GetFirstGuidHob (&gEfiXenInfoGuid);
+  if (GuidHob.Raw != NULL) {
+    mXenInfo = GET_GUID_HOB_DATA (GuidHob.Guid);
+    if (mXenInfo != NULL) {
+      return (VOID *) (UINTN) mXenInfo->HyperPages;
+    }
+  } 
+
+  DEBUG ((EFI_D_ERROR, "Gasket_Fail to get Xen info from hob\n"));
+  return NULL;
+}
+
Index: OvmfPkg/Library/XenHypercallLib/GasketHypercall.h
===================================================================
--- OvmfPkg/Library/XenHypercallLib/GasketHypercall.h	(revision 0)
+++ OvmfPkg/Library/XenHypercallLib/GasketHypercall.h	(revision 0)
@@ -0,0 +1,44 @@
+/** @file
+
+  Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#ifndef _GASKET_HYPERCALL_H_
+#define _GASKET_HYPERCALL_H_
+
+UINTN
+EFIAPI
+Hypercall (
+  IN  VOID   *HypercallPageAddress,  // Address of hypercall page
+  IN  UINTN  HypercallOffset,        // Hypercall Offset ( = hypercall num * 32)
+  IN  UINTN  Arg1,                   // parameters
+  IN  UINTN  Arg2,                   //
+  IN  UINTN  Arg3,                   //
+  IN  UINTN  Arg4,                   //
+  IN  UINTN  Arg5                    //
+  );
+
+
+//
+// Hypercall2 is not used!
+//
+UINTN
+EFIAPI
+Hypercall2 (
+  IN  VOID   *HypercallPageAddress,  // Address of hypercall page
+  IN  UINTN  HypercallOffset,        // Hypercall Offset ( = hypercall num * 32)
+  IN  UINTN  Arg1,                   // parameters
+  IN  UINTN  Arg2                    //
+  );
+
+#endif
+
Index: OvmfPkg/Library/XenHypercallLib/XenHypercallLib.h
===================================================================
--- OvmfPkg/Library/XenHypercallLib/XenHypercallLib.h	(revision 0)
+++ OvmfPkg/Library/XenHypercallLib/XenHypercallLib.h	(revision 0)
@@ -0,0 +1,30 @@
+/** @file
+Provide Xen Hypercall.
+
+Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+
+This program and the accompanying materials
+are licensed and made available under the terms and conditions of the BSD License
+which accompanies this distribution.  The full text of the license may be found at
+http://opensource.org/licenses/bsd-license.php
+
+THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#ifndef _XEN_HYPERCALL_LIB_H_
+#define _XEN_HYPERCALL_LIB_H_
+
+#include <PiDxe.h>
+
+#include <Library/HobLib.h>
+#include <Library/DebugLib.h>
+#include <Guid/XenInfo.h>
+
+#include <Library/XenHypercallLib.h>
+#include <Library/XenLib.h>
+#include "GasketHypercall.h"
+
+#endif
+
Index: OvmfPkg/Library/XenHypercallLib/Ia32/GasketHypercall.S
===================================================================
--- OvmfPkg/Library/XenHypercallLib/Ia32/GasketHypercall.S	(revision 0)
+++ OvmfPkg/Library/XenHypercallLib/Ia32/GasketHypercall.S	(revision 0)
@@ -0,0 +1,96 @@
+#------------------------------------------------------------------------------
+#
+# Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+#
+# This program and the accompanying materials
+# are licensed and made available under the terms and conditions of the BSD License
+# which accompanies this distribution.  The full text of the license may be found at
+# http://opensource.org/licenses/bsd-license.php.
+#
+# THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+# WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+# Module Name:
+#
+#   GasketHypercall.S
+#
+# Abstract:
+#
+#   Hypercall function
+#
+# Notes:
+#
+#------------------------------------------------------------------------------
+
+#------------------------------------------------------------------------------
+#  UINTN
+#  EFIAPI
+#  Hypercall (
+#    IN  VOID   *HypercallPageAddress,  // passed in stack 8(%ebp)
+#    IN  UINTN  HypercallOffset,        // passed in stack 12(%ebp)
+#    IN  UINTN  Arg1,                   // passed in stack 16(%ebp)
+#    IN  UINTN  Arg2,                   // passed in stack 20(%ebp)
+#    IN  UINTN  Arg3,                   // passed in stack 24(%ebp)
+#    IN  UINTN  Arg4,                   // passed in stack 28(%ebp)
+#    IN  UINTN  Arg5,                   // passed in stack 32(%ebp)
+#    )
+#------------------------------------------------------------------------------
+
+  .text
+
+ASM_GLOBAL ASM_PFX(Hypercall)
+ASM_PFX(Hypercall):
+  pushl %ebp
+  movl  %esp, %ebp
+
+  pushl %ebx
+  pushl %ecx
+  pushl %edx
+  pushl %esi
+  pushl %edi  
+
+  movl 8(%ebp), %eax     // Address of hypercall page
+  addl 12(%ebp), %eax    // Address of hypercall is in %rax
+
+  movl 32(%ebp), %edi    // Swizzle args
+  movl 28(%ebp), %esi
+  movl 24(%ebp), %edx
+  movl 20(%ebp), %ecx
+  movl 16(%ebp), %ebx
+
+  call  *%eax
+
+  popl %edi
+  popl %esi
+  popl %edx
+  popl %ecx
+  popl %ebx
+
+  movl %ebp, %esp
+  popl %ebp
+  ret
+
+
+//
+// Hypercall2 is not used.
+//
+ASM_GLOBAL ASM_PFX(Hypercall2)
+ASM_PFX(Hypercall2):
+  pushl	%ebp
+  movl	%esp, %ebp
+
+  pushl %ecx
+
+  movl 8(%ebp), %eax     // Address of hypercall page
+  addl 12(%ebp), %eax    // Address of hypercall is in %rax
+
+  movl 20(%ebp), %ecx    // Swizzle args
+  movl 16(%ebp), %ebx
+ 
+  call *%eax
+
+  popl %ecx
+  movl %ebp, %esp
+  popl %ebp
+  ret
+
Index: OvmfPkg/OvmfPkgX64.fdf
===================================================================
--- OvmfPkg/OvmfPkgX64.fdf	(revision 12124)
+++ OvmfPkg/OvmfPkgX64.fdf	(working copy)
@@ -150,9 +150,12 @@
 INF  MdeModulePkg/Universal/PCD/Dxe/Pcd.inf
 
 INF  MdeModulePkg/Core/RuntimeDxe/RuntimeDxe.inf
+#
+# Xen PV Library Test
+#
+INF  OvmfPkg/HypercallTestDxe/HypercallTestDxe.inf
 INF  MdeModulePkg/Universal/SecurityStubDxe/SecurityStubDxe.inf
 INF  MdeModulePkg/Universal/EbcDxe/EbcDxe.inf
-INF  MdeModulePkg/Universal/SmbiosDxe/SmbiosDxe.inf
 INF  PcAtChipsetPkg/8259InterruptControllerDxe/8259.inf
 INF  UefiCpuPkg/CpuIo2Dxe/CpuIo2Dxe.inf
 INF  UefiCpuPkg/CpuDxe/CpuDxe.inf
@@ -198,6 +201,9 @@
 INF  IntelFrameworkModulePkg/Bus/Isa/Ps2KeyboardDxe/Ps2keyboardDxe.inf
 INF  IntelFrameworkModulePkg/Bus/Isa/IsaFloppyDxe/IsaFloppyDxe.inf
 
+INF  MdeModulePkg/Universal/SmbiosDxe/SmbiosDxe.inf
+INF  OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.inf
+
 INF  MdeModulePkg/Universal/Acpi/AcpiTableDxe/AcpiTableDxe.inf
 INF  MdeModulePkg/Universal/Acpi/AcpiPlatformDxe/AcpiPlatformDxe.inf
 INF  RuleOverride=ACPITABLE OvmfPkg/AcpiTables/AcpiTables.inf
