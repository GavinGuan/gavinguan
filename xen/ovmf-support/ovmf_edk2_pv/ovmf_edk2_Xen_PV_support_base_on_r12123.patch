Index: OvmfPkg/HypercallTestDxe/HypercallTestDxe.inf
===================================================================
--- OvmfPkg/HypercallTestDxe/HypercallTestDxe.inf	(revision 0)
+++ OvmfPkg/HypercallTestDxe/HypercallTestDxe.inf	(revision 0)
@@ -0,0 +1,52 @@
+## @file
+#  Xen PV test.
+#
+#  Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+#
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution. The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = HypercallTestDxe
+  FILE_GUID                      = 9169e45e-5db7-4b5c-9d1e-016fec787c2c
+  MODULE_TYPE                    = DXE_DRIVER
+  VERSION_STRING                 = 1.0
+
+  ENTRY_POINT                    = XenParaVirtualizationTestEntry
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64 IPF EBC
+#
+
+[Sources]
+  HypercallTestDxe.h
+  HypercallTestDxe.c
+
+[Packages]
+  MdePkg/MdePkg.dec
+  OvmfPkg/OvmfPkg.dec
+
+[LibraryClasses]
+  UefiDriverEntryPoint
+  UefiBootServicesTableLib
+  XenHypercallLib
+  XenLib
+  DebugLib
+  HobLib
+  BaseLib
+
+[Guids]
+  gEfiXenInfoGuid
+
+[Depex]
+  TRUE
Index: OvmfPkg/HypercallTestDxe/HypercallTestDxe.c
===================================================================
--- OvmfPkg/HypercallTestDxe/HypercallTestDxe.c	(revision 0)
+++ OvmfPkg/HypercallTestDxe/HypercallTestDxe.c	(revision 0)
@@ -0,0 +1,202 @@
+/** @file
+  Xen PV test Dxe.
+
+  Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+
+  This program and the accompanying materials                          
+  are licensed and made available under the terms and conditions of the BSD License         
+  which accompanies this distribution.  The full text of the license may be found at        
+  http://opensource.org/licenses/bsd-license.php                                            
+                                                                                          
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,                     
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.             
+
+**/
+
+#include "HypercallTestDxe.h"
+
+/**
+  Helper functions: print a string. (For Hypercall test)
+**/
+UINTN
+EFIAPI
+PrintAsciiStr (
+  IN      CONST CHAR8               *FirstString,
+  IN      UINTN                     Length
+  )
+{
+  ASSERT (AsciiStrSize (FirstString));
+
+  while ((*FirstString != '\0') && (Length > 0)) {
+    DEBUG ((EFI_D_INFO, "%c", *FirstString));
+    FirstString++;
+    Length--;
+  }
+
+  DEBUG ((EFI_D_INFO, "\n"));
+  return EFI_SUCCESS;
+}
+
+
+/**
+  Test Xen Hypercall. You can use hypercall in this function.
+
+**/
+EFI_STATUS
+EFIAPI
+HypercallTestFunc (
+  VOID
+  )
+{
+  EFI_STATUS         Status;
+  UINT32             Major, Minor;
+  XenExtraversion    ExtraVersion;
+
+  Major = 0; Minor = 0;
+  Minor = HypervisorXenVersion(XENVER_VERSION, 0);
+  Major = Minor >> 16;
+  Minor &= 0xFFFF;
+  DEBUG ((EFI_D_INFO, "[HypercallTest_CallHypercallFromDXE]OVMF is running on Xen version: %d.%d\n", Major, Minor));
+
+  Status = HypervisorXenVersion(XENVER_EXTRAVERSION, ExtraVersion);
+  ASSERT_EFI_ERROR (Status);
+  DEBUG ((EFI_D_INFO, "[HypercallTest_CallHypercallFromDXE]Detected Xen"));
+  PrintAsciiStr(ExtraVersion, 16);
+
+  return EFI_SUCCESS;
+}
+
+/**
+  Test XenBus: Read and write a key-value pair in Xenstore.
+
+**/
+EFI_STATUS
+EFIAPI
+XenbusTestFunc (
+  VOID
+  )
+{
+  //
+  // Pointer to the value of a key in Xenstore.
+  //
+  CHAR8            *XenstoreValue;
+  //
+  // Array of pointers to keys of a directory.
+  //
+  CHAR8            **XenstoreValuePtrs;
+  UINTN            Index;
+  DOMID            DomId;
+
+  //
+  // Set Xenbus.
+  //
+  XenbusSetup ();
+
+  //
+  // Get current domain ID
+  //
+  DomId = XenbusGetDomId ();
+  if (DomId < 0) {
+    DEBUG ((EFI_D_ERROR, "Can't get domain ID!\n"));
+  }
+  else {
+    DEBUG ((EFI_D_INFO, "[XenbusTest_GetDomIdFromXenstore] Domain Id: %d\n", DomId));
+  }
+
+  //
+  // Read a value from xenstore.
+  //
+  XenstoreValue = NULL;
+  XenbusRead ("hvmloader/bios", &XenstoreValue);
+  DEBUG ((EFI_D_INFO, "[XenbusTest_ReadXenstore] Old HVM BIOS (hvmloader/bios): "));
+  PrintAsciiStr(XenstoreValue, 30);
+
+  XenbusRead ("name", &XenstoreValue);
+  DEBUG ((EFI_D_INFO, "[XenbusTest_ReadXenstore] Old HVM BIOS (name): "));
+  PrintAsciiStr(XenstoreValue, 30);
+
+  //
+  // Write a value into xenstore.
+  // TODO modify failed!!
+  //
+  DEBUG ((EFI_D_INFO, "[XenbusTest_WriteXenstore] Write to Xenstore\n"));
+  XenbusWrite ("hvmloader/bios", "ovmf-pv-test");
+  XenbusRead ("hvmloader/bios", &XenstoreValue);
+  DEBUG ((EFI_D_INFO, "[XenbusTest_WriteXenstore] New HVM BIOS (hvmloader/bios): "));
+  PrintAsciiStr(XenstoreValue, 30);
+
+  //
+  // Create a new key in Xenstore
+  //
+  //DEBUG ((EFI_D_INFO, "[XenbusTest_WriteXenstore_2] Write to Xenstore\n"));
+  //XenbusWrite ("testkey", "ovmf-hvm");
+  //XenbusRead ("testkey", &XenstoreValue);
+  //DEBUG ((EFI_D_INFO, "[XenbusTest_ReadXenstore] Old HVM BIOS (testkey): "));
+  //PrintAsciiStr(XenstoreValue, 30);
+
+  //
+  // List a directory in xenstore.
+  //
+  XenstoreValuePtrs = NULL;
+  XenbusLs ("device", &XenstoreValuePtrs);
+  if (XenstoreValuePtrs) {
+    DEBUG ((EFI_D_INFO, "[XenbusTest_ReadDireXenstore] Diretory in Xenstore (device): \n"));
+    for (Index = 0; Index < (XENSTORE_PAYLOAD_MAX + 1); Index++) {
+      if (!XenstoreValuePtrs[Index]) {
+        break;
+      }
+      PrintAsciiStr((CHAR8 *) (UINTN) XenstoreValuePtrs[Index] , 30);
+    }
+  }
+
+  //
+  // Clear the Xenbus.
+  //
+  XenbusShutdown ();
+
+  return EFI_SUCCESS;
+}
+
+/**
+  Stub Dxe.
+
+  @param ImageHandle     Module's image handle
+  @param SystemTable     Pointer of EFI_SYSTEM_TABLE
+
+  @retval EFI_SUCCESS    Smbios protocol installed
+  @retval Other          No protocol installed, unload driver.
+
+**/
+EFI_STATUS
+EFIAPI
+XenParaVirtualizationTestEntry (
+  IN EFI_HANDLE           ImageHandle,
+  IN EFI_SYSTEM_TABLE     *SystemTable
+  )
+{
+  VOID *HypercallPages;
+
+  //
+  // Test if we can use Xen Hypercalls.
+  //
+  HypercallPages = InitializeHypercallPage ();
+  if (HypercallPages == NULL) {
+    DEBUG ((EFI_D_ERROR, "Can't find HVM hypercall page!\n"));
+    return 0;
+  }
+ 
+  //
+  // Test Xen Hypercall.
+  //
+  HypercallTestFunc();
+
+  //
+  // Test Xenbus.
+  // Read or Write a key-value in xenstore
+  //
+  XenbusTestFunc();
+
+
+  return EFI_SUCCESS;
+}
+
Index: OvmfPkg/HypercallTestDxe/HypercallTestDxe.h
===================================================================
--- OvmfPkg/HypercallTestDxe/HypercallTestDxe.h	(revision 0)
+++ OvmfPkg/HypercallTestDxe/HypercallTestDxe.h	(revision 0)
@@ -0,0 +1,31 @@
+/** @file
+  Xen PV test Dxe.
+
+  Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+
+  This program and the accompanying materials                          
+  are licensed and made available under the terms and conditions of the BSD License         
+  which accompanies this distribution.  The full text of the license may be found at        
+  http://opensource.org/licenses/bsd-license.php                                            
+                                                                                          
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,                     
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.             
+
+**/
+
+#ifndef _HYPERCALL_TEST_DXE_H_
+#define _HYPERCALL_TEST_DXE_H_
+
+#include <PiDxe.h>
+
+#include <Library/XenHypercallLib.h>
+#include <Library/XenLib.h>
+#include <Library/HobLib.h>
+#include <Library/DebugLib.h>
+#include <Library/UefiBootServicesTableLib.h>
+#include <Library/UefiDriverEntryPoint.h>
+#include <Library/BaseLib.h>
+#include <Guid/XenInfo.h>
+
+#endif
+
Index: OvmfPkg/Include/Library/XenLib.h
===================================================================
--- OvmfPkg/Include/Library/XenLib.h	(revision 0)
+++ OvmfPkg/Include/Library/XenLib.h	(revision 0)
@@ -0,0 +1,436 @@
+/** @file
+
+  XEN_HV_PROTOCOL protocol allows consumers to log SMBIOS data records, and enables the producer 
+  to create the SMBIOS tables for a platform.
+
+  Copyright (c) 2006 - 2008, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials                          
+  are licensed and made available under the terms and conditions of the BSD License         
+  which accompanies this distribution.  The full text of the license may be found at        
+  http://opensource.org/licenses/bsd-license.php                                            
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,                     
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.             
+
+**/
+
+#ifndef __XEN_LIB__
+#define __XEN_LIB__
+
+/**
+  All Xen PV driver need struct and methods are defined here.
+
+**/
+
+///
+/// Guest OS interface to Xen.
+///
+#define DOMID_FIRST_RESERVED (0x7FF0U)
+#define DOMID_SELF           (0x7FF0U)
+#define DOMID_IO             (0x7FF1U)
+#define DOMID_XEN            (0x7FF2U)
+#define DOMID_COW            (0x7FF3U)
+#define DOMID_INVALID        (0x7FF4U)
+#define DOMID_IDLE           (0x7FFFU)
+
+///
+/// For HVM-guest Xenbus implementation.
+///
+#define HVM_PARAM_STORE_PFN    1
+#define HVM_PARAM_STORE_EVTCHN 2
+
+
+///
+/// For Xen Version Hypercall
+///
+#define XENVER_VERSION         0
+#define XENVER_EXTRAVERSION    1
+typedef CHAR8 XenExtraversion[16];
+
+
+//
+// For HVM Hypercall (HYPERVISOR_HVM_OP)
+//
+#define HVMOP_SET_PARAM        0
+#define HVMOP_GET_PARAM        1
+//typedef UINT16                 DOMID;
+typedef struct {
+  DOMID             DomId;
+  UINT32            Index;
+  UINTN             Value;
+} EFI_XEN_HVM_PARAM;
+
+
+//
+// For Sched Hypercall (HYPERVISOR_SCHED_OP)
+//
+
+#define SCHEDOP_SHUTDOWN       2
+#define SCHEDOP_POLL           3
+typedef struct {
+  UINT32            *Ptr;
+} XEN_GUEST_HANDLE;
+
+typedef struct {
+  XEN_GUEST_HANDLE  Ports;
+  UINT32            NrPorts;
+  UINTN             Timeout;
+} SCHED_POLL;
+
+//
+// Reason codes for SCHEDOP_SHUTDOWN
+//
+#define SHUTDOWN_POWEROFF      0
+#define SHUTDOWN_REBOOT        1
+#define SHUTDOWN_SUSPEND       2
+#define SHUTDOWN_CRASH         3
+#define SHUTDOWN_WATCHDOG      4
+
+
+//
+// For Memory Hypercall (HYPERVISOR_MEMORY_OP)
+//
+//typedef UINTN          XEN_PFN;
+
+#define XENMEM_ADD_TO_PHYSMAP          7
+#define XENMAPSPACE_SHARED_INFO        0
+#define XENMAPSPACE_GRANT_TABLE        1
+#define XENMAPSPACE_Gmfn               2
+#define XENMAPIDX_GRANT_TABLE_STATUS   0x80000000
+typedef struct {
+  //
+  // Which domain to change the mapping for.
+  //
+  DOMID          DomId;
+  //
+  // Source mapping space.
+  //
+  UINT32         Space;
+  //
+  // Index into source mapping space.
+  //
+  UINTN          Index;
+  //
+  // GPFN (Guset Page Frame Number) where the source mapping page should appear.
+  //
+  XEN_PFN        Gpfn;
+} XEN_ADD_TO_PHYSMAP;
+
+
+
+///
+/// Event Channel stuff
+///
+typedef UINT32 EFI_EVENT_CHANNEL_PORT;
+
+//
+// Send an event to the remote end of the channel whose local endpoint is Port.
+//
+#define EVTCHNOP_SEND         4
+typedef struct {
+  EFI_EVENT_CHANNEL_PORT  Port;
+} EVENT_CHANNEL_SEND;
+
+
+
+///
+/// Xenbus stuff
+///
+
+//
+// Xen Store socket message type between Xen Store Daemon and client library or Guest VM.
+//
+typedef enum {
+  XSDebug,
+  XSDirectory,
+  XSRead,
+  XSGetPerms,
+  XSWatch,
+  XSUnwatch,
+  XSTransactionStart,
+  XSTransactionEnd,
+  XSIntroduce,
+  XSRelease,
+  XSGetDomainPath,
+  XSWrite,
+  XSMkdir,
+  XSRm,
+  XSSetPerms,
+  XSWatchEvent,
+  XSError,
+  XSIsDomainIntroduced,
+  XSResume,
+  XSSetTarget,
+  XSRestrict
+} EFI_XENSTORE_MSG_TYPE;
+
+//
+// Xen Store message struct 
+//
+typedef struct {
+  //
+  // Xen Store socket message type
+  //
+  EFI_XENSTORE_MSG_TYPE    Type;
+  //
+  // Request identifier
+  //
+  UINT32                   RequestId;
+  //
+  // Transaction id. If don't use transactions, just set 0.
+  //
+  UINT32                   TransactionId;
+  //
+  // Length of data following this
+  //
+  UINT32                   Length;
+} EFI_XENSTORE_MSG;
+
+//
+// Xen Store request
+//
+typedef struct {
+  CHAR8                    *Data;
+  UINTN                    Length;
+} EFI_XENSTORE_REQUEST;
+
+#define ARRAY_SIZE(arr) (sizeof(arr)/sizeof(arr[0]))
+
+//
+// Inter-domain shared memory communications.
+//
+#define XENSTORE_RING_SIZE 1024
+typedef UINT32 XENSTORE_RING_IDX;
+typedef struct {
+  //
+  // Requests to Xenstore daemon.
+  //
+  CHAR8               Req[XENSTORE_RING_SIZE];
+  //
+  // Replies from Xenstore daemon.
+  //
+  CHAR8               Rsp[XENSTORE_RING_SIZE];
+
+  XENSTORE_RING_IDX   ReqCons;
+  XENSTORE_RING_IDX   ReqProd;
+  XENSTORE_RING_IDX   RspCons;
+  XENSTORE_RING_IDX   RspProd;
+} EFI_XENSTORE_DOMAIN_INTERFACE;
+
+#define XENSTORE_PAYLOAD_MAX  4096
+
+/**
+  Connect to the backend Xenbus daemon. 
+  This method must be called first before any Xenbus operation.
+
+  @return              EFI_STATUS.
+
+**/
+EFI_STATUS
+EFIAPI
+XenbusSetup (
+  VOID
+  );
+
+/**
+  Reset the Xenbus connection.
+
+  @return              EFI_STATUS.
+
+**/
+EFI_STATUS
+EFIAPI
+XenbusShutdown (
+  VOID
+  );
+
+/**
+  Read a Xenstore key. Returns a nul-terminated string or NULL.
+
+  @param IN  Path            The Xenstore key path.
+  @param OUT Data            The value to of the key.
+
+  @return EFI_SUCCESS        Successly.
+  @return Other              Error.
+
+**/
+EFI_STATUS
+EFIAPI
+XenbusRead (
+  IN     CHAR8                    *Path,
+  OUT    CHAR8                    **Data
+  );
+
+/**
+  Create or modify a Xenstore key.
+
+  @param IN  Path            The Xenstore key path.
+  @param IN  Data            The value to of the key.
+
+  @return EFI_SUCCESS        Successly.
+  @return Other              Error.
+
+**/
+EFI_STATUS
+EFIAPI
+XenbusWrite (
+  IN     CHAR8                    *Path,
+  IN     CHAR8                    *Data
+  );
+
+/**
+  List a Xenstore directory.
+
+  @param IN  Path            The Xenstore key path.
+  @param OUT DataArray       A array of pointers to the key under the directory.
+
+  @return EFI_SUCCESS        Successly.
+  @return Other              Error.
+
+**/
+EFI_STATUS
+EFIAPI
+XenbusLs (
+  IN     CHAR8                    *Path,
+  OUT    CHAR8                    ***DataArray
+  );
+
+/**
+  Get domain ID from xenstore.
+
+  @return  The ID of surrent Domain.
+
+**/
+DOMID
+EFIAPI
+XenbusGetDomId (
+  VOID
+  );
+
+
+///
+/// Common functions used by Xen PV mechanism
+///
+
+//
+// Maximum number of virtual CPUs in multi-processor guests.
+//
+#define XEN_LEGACY_MAX_VCPUS 32
+
+//
+// Definitions for architecture-specific types
+//
+#if   defined (MDE_CPU_IA32)
+//
+// The IA-32 architecture struct used by VCPU_INFO.
+//
+typedef struct {
+  UINTN                 CR2;
+  UINTN                 Pad[5];
+} ARCH_VCPU_INFO;
+
+#endif // defined (MDE_CPU_IA32)
+
+#if defined (MDE_CPU_X64)
+//
+// The X64 architecture struct used by VCPU_INFO.
+//
+typedef struct {
+  UINTN                 CR2;
+  UINTN                 Pad;
+} ARCH_VCPU_INFO;
+
+#endif // defined (MDE_CPU_X64)
+
+typedef struct {
+  //
+  // Max PFN (Physical Frame Number).
+  //
+  UINTN                 MaxPfn;
+  //
+  // Frame containing list of mfns containing list of mfns containing p2m.
+  //
+  XEN_PFN               P2MFrameListList;
+
+  UINTN                 NmiReason;
+  UINT64                Pad[32];
+} __attribute__((__packed__)) ARCH_SHARED_INFO;
+
+typedef struct {
+  UINT32                Version;
+  UINT32                Pad0;
+  //
+  // TSC time at last update of time value.
+  //
+  UINT64                TscTimestamp;
+  //
+  // Time, in nanosecs, since boot.
+  //
+  UINT64                SystemTime;
+  //
+  // Current system time.
+  //
+  UINT32                TscToSystemMul;
+  INT8                  TscShift;
+  INT8                  Pad1[3];
+} VCPU_TIME_INFO;
+
+typedef struct {
+  UINT8                 EvtChnUpcallPending;
+  UINT8                 EvtChnUpcallMask;
+  UINTN                 EvtChnPendingSel;
+  
+  ARCH_VCPU_INFO        Arch;
+  VCPU_TIME_INFO        Time;
+} VCPU_INFO;
+
+//
+// EFI_XEN_SHARED_INFO: Xen shared_info_page
+//
+typedef struct {
+  VCPU_INFO             VcpuInfo[XEN_LEGACY_MAX_VCPUS];
+  //
+  // Each channel is associated with two bits of information: PENDING and MASK.
+  //
+  UINTN                 EventChannelPending[sizeof (UINTN) * 8];
+  UINTN                 EventChannelMask[sizeof (UINTN) * 8];
+  //
+  // Wallclock time.
+  //
+  UINT32                WallClockVersion;
+  UINT32                WallClockSecond;
+  UINT32                WallClockNanosecond;
+
+  ARCH_SHARED_INFO      Arch;
+} EFI_XEN_SHARED_INFO;
+
+/**
+  Get shared info page.
+
+  @return A pointer to shared info page.
+
+**/
+VOID *
+EFIAPI
+GetSharedInfo (
+  VOID
+  );
+
+/**
+  Test and clear one bit at a gavin address.
+
+  @param IN BitNum   The number of bit to operate.
+  @param IN Addr     The address to operate.
+
+  @return  The old value of the bit.
+
+**/
+UINTN
+EFIAPI
+SyncTestClearBit (
+  IN     UINTN                    BitNum,
+  IN     VOID                     *Addr
+  );
+
+#endif //__XEN_LIB__
+
Index: OvmfPkg/Include/Library/XenHypercallLib.h
===================================================================
--- OvmfPkg/Include/Library/XenHypercallLib.h	(revision 0)
+++ OvmfPkg/Include/Library/XenHypercallLib.h	(revision 0)
@@ -0,0 +1,664 @@
+/** @file
+
+  This library provides consumers all Xen Hypercall.
+
+  Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+
+  This program and the accompanying materials                          
+  are licensed and made available under the terms and conditions of the BSD License         
+  which accompanies this distribution.  The full text of the license may be found at        
+  http://opensource.org/licenses/bsd-license.php                                            
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,                     
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.             
+
+**/
+
+#ifndef __XEN_HYPERCALL_LIB__
+#define __XEN_HYPERCALL_LIB__
+
+//
+// HYPERCALLS NUMBER
+//
+#define HYPERVISOR_SET_TRAP_TABLE          0
+#define HYPERVISOR_MMU_UPDATE              1
+#define HYPERVISOR_SET_GDT                 2
+#define HYPERVISOR_STACK_SWITCH            3
+#define HYPERVISOR_SET_CALLBACKS           4
+#define HYPERVISOR_FPU_TASKSWITCH          5
+#define HYPERVISOR_SCHED_OP_COMPAT         6
+#define HYPERVISOR_PLATFORM_OP             7
+#define HYPERVISOR_SET_DEBUGREG            8
+#define HYPERVISOR_GET_DEBUGREG            9
+#define HYPERVISOR_UPDATE_DESCRIPTOR       10
+#define HYPERVISOR_MEMORY_OP               12
+#define HYPERVISOR_MULTICALL               13
+#define HYPERVISOR_UPDATE_VA_MAPPING       14
+#define HYPERVISOR_SET_TIMER_OP            15
+#define HYPERVISOR_EVENT_CHANNEL_OP_COMPAT 16
+#define HYPERVISOR_XEN_VERSION             17
+#define HYPERVISOR_CONSOLE_IO              18
+#define HYPERVISOR_PHYSDEV_OP_COMPAT       19
+#define HYPERVISOR_GRANT_TABLE_OP          20
+#define HYPERVISOR_VM_ASSIST               21
+#define HYPERVISOR_UPDATE_VA_MAPPING_OTHERDOMAIN 22
+#define HYPERVISOR_IRET                    23
+#define HYPERVISOR_VCPU_OP                 24
+#define HYPERVISOR_SET_SEGMENT_BASE        25
+#define HYPERVISOR_MMUEXT_OP               26
+#define HYPERVISOR_XSM_OP                  27
+#define HYPERVISOR_NMI_OP                  28
+#define HYPERVISOR_SCHED_OP                29
+#define HYPERVISOR_CALLBACK_OP             30
+#define HYPERVISOR_XENOPROF_OP             31
+#define HYPERVISOR_EVENT_CHANNEL_OP        32
+#define HYPERVISOR_PHYSDEV_OP              33
+#define HYPERVISOR_HVM_OP                  34
+#define HYPERVISOR_SYSCTL                  35
+#define HYPERVISOR_DOMCTL                  36
+#define HYPERVISOR_KEXEC_OP                37
+#define HYPERVISOR_TMEM_OP                 38
+
+#define HYPERVISOR_ARCH_0                  48
+#define HYPERVISOR_ARCH_1                  49
+#define HYPERVISOR_ARCH_2                  50
+#define HYPERVISOR_ARCH_3                  51
+#define HYPERVISOR_ARCH_4                  52
+#define HYPERVISOR_ARCH_5                  53
+#define HYPERVISOR_ARCH_6                  54
+#define HYPERVISOR_ARCH_7                  55
+
+///
+/// Structs for Hypercall parameters.
+///
+typedef UINT16                 DOMID;
+typedef UINTN                  XEN_PFN;
+
+typedef struct {
+  //
+  // Exception vector
+  //
+  UINT8        Vector;
+  //
+  // 0-3: privilege level; 4: clear event enable?
+  //
+  UINT8        Flags;
+  //
+  // Code selector
+  //
+  UINT16       CS;
+  //
+  // Code offset
+  //
+  UINTN        Address;
+} TRAP_INFO;
+
+typedef struct {
+  //
+  // Machine address of PTE
+  //
+  UINT64       Ptr;
+  //
+  // New contents of PTE
+  //
+  UINT64       Val;
+} MMU_UPDATE;
+
+typedef struct {
+  UINT32       Cmd;
+  union {
+    XEN_PFN      Mfn;
+    UINTN        LinearAddr;
+  } Arg1;
+  union {
+    UINT32       NrEnts;
+    //
+    // This item has something to do with xen interface version.
+    //
+    const VOID   *Vcpumask;
+
+    XEN_PFN      SrcMfn;
+  } Arg2;
+} MMUEXT_OP;
+
+//
+// Definitions for architecture-specific types
+//
+#if   defined (MDE_CPU_IA32)
+typedef struct {
+    UINTN        PteLow;
+    UINTN        PteHigh;
+} PTE;
+#endif
+
+#if defined (MDE_CPU_X64)
+typedef struct {
+    UINTN        Pte;
+} PTE;
+#endif
+
+/**
+  Hypercall methods.
+
+  @param[in]    TODO parameters description. Make clear of IN and OUT of the parameters
+
+**/
+/**
+  Hypercall #0: HYPERVISOR_SET_TRAP_TABLE
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorSetTrapTable (
+  IN OUT TRAP_INFO     *Table
+  );
+
+/**
+  Hypercall #1: HYPERVISOR_MMU_UPDATE
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorMmuUpdate (
+  IN  MMU_UPDATE    *Req,
+  IN  UINTN         Count,
+  OUT UINTN         *SuccessCount,
+  IN  DOMID         DomId
+  );
+
+/**
+  Hypercall #2: HYPERVISOR_SET_GDT
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorSetGdt (
+  IN  UINTN         *FrameList,
+  IN  UINTN         Entries
+  );
+
+/**
+  Hypercall #3: HYPERVISOR_STACK_SWITCH
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorStackSwitch (
+  IN  UINTN         SS,
+  IN  UINTN         Esp
+  );
+
+/**
+  Hypercall #4: HYPERVISOR_SET_CALLBACKS
+  TODO Untested
+**/
+#if   defined (MDE_CPU_IA32)
+EFI_STATUS
+EFIAPI
+HypervisorSetCallbacks (
+  IN  UINTN         EventSelector,
+  IN  UINTN         EventAddress,
+  IN  UINTN         FailsafeSelector,
+  IN  UINTN         FailsafeAddress
+  );
+#endif
+
+#if defined (MDE_CPU_X64)
+EFI_STATUS
+EFIAPI
+HypervisorSetCallbacks (
+  IN  UINTN         EventAddress,
+  IN  UINTN         FailsafeAddress,
+  IN  UINTN         SyscallAddress
+  );
+#endif
+
+/**
+  Hypercall #5: HYPERVISOR_FPU_TASKSWITCH
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorFpuTaskswitch (
+  IN  UINTN         Set
+  );
+
+/**
+  Hypercall #6: HYPERVISOR_SCHED_OP_COMPAT
+**/
+EFI_STATUS
+EFIAPI
+HypervisorSchedOpCompat (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #7: HYPERVISOR_PLATFORM_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorPlatformOp (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #8: HYPERVISOR_SET_DEBUGREG
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorSetDebugreg (
+  IN  UINTN         Reg,
+  IN  UINTN         Value
+  );
+
+/**
+  Hypercall #9: HYPERVISOR_GET_DEBUGREG
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorGetDebugreg (
+  IN  UINTN         Reg
+  );
+
+/**
+  Hypercall #10: HYPERVISOR_UPDATE_DESCRIPTOR
+  TODO Untested
+**/
+#if   defined (MDE_CPU_IA32)
+EFI_STATUS
+EFIAPI
+HypervisorUpdateDescriptor (
+  IN  UINT64        Ma,
+  IN  UINT64        Desc
+  );
+#endif
+
+#if defined (MDE_CPU_X64)
+EFI_STATUS
+EFIAPI
+HypervisorUpdateDescriptor (
+  IN  UINTN         Ma,
+  IN  UINTN         Word
+  );
+#endif
+
+/**
+  Hypercall #12: HYPERVISOR_MEMORY_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorMemoryOp (
+  IN  UINTN         Cmd,
+  IN  VOID          *Arg
+  );
+
+/**
+  Hypercall #13: HYPERVISOR_MULTICALL
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorMulticall (
+  IN  VOID          *CallList,
+  IN  UINTN         NrCalls
+  );
+
+/**
+  Hypercall #14: HYPERVISOR_UPDATE_VA_MAPPING
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorUpdateVaMapping (
+  IN  UINTN         Va,
+  IN  PTE           NewVal,
+  IN  UINTN         Flags
+  );
+
+/**
+  Hypercall #15: HYPERVISOR_SET_TIMER_OP
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorSetTimerOp (
+  IN UINT64     Timeout
+  );
+
+/**
+  Hypercall #16: HYPERVISOR_EVENT_CHANNEL_OP_COMPAT
+**/
+EFI_STATUS
+EFIAPI
+HypervisorEventChannelOpCompat (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #17: HYPERVISOR_XEN_VERSION
+**/
+EFI_STATUS
+EFIAPI
+HypervisorXenVersion (
+  IN UINTN Cmd,
+  IN VOID  *Arg
+  );
+
+/**
+  Hypercall #18: HYPERVISOR_CONSOLE_IO
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorConsoleIo (
+  IN  UINTN         Cmd,
+  IN  UINTN         Count,
+  OUT CHAR8         *Str
+  );
+
+/**
+  Hypercall #19: HYPERVISOR_PHYSDEV_OP_COMPAT
+**/
+EFI_STATUS
+EFIAPI
+HypervisorPhysdevOpCompat (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #20: HYPERVISOR_GRANT_TABLE_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorGrantTableOp(
+  IN UINTN      Cmd,
+  IN VOID       *Uop,
+  IN UINTN      Count
+);
+
+/**
+  Hypercall #21: HYPERVISOR_VM_ASSIST
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorVmAssist (
+  IN  UINTN         Cmd,
+  IN  UINTN         Type
+  );
+
+/**
+  Hypercall #22: HYPERVISOR_UPDATE_VA_MAPPING_OTHERDOMAIN
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorUpdateVaMappingOtherdomain (
+  IN  UINTN         Va,
+  IN  PTE           NewVal,
+  IN  UINTN         Flags,
+  IN  DOMID         DomId
+  );
+
+/**
+  Hypercall #23: HYPERVISOR_IRET
+**/
+EFI_STATUS
+EFIAPI
+HypervisorIret (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #24: HYPERVISOR_VCPU_OP
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorVcpuOp (
+  IN  UINTN         Cmd,
+  IN  UINTN         VcpuId,
+  IN  VOID          *ExtraArgs
+  );
+
+/**
+  Hypercall #25: HYPERVISOR_SET_SEGMENT_BASE
+  TODO Untested
+**/
+#if defined (MDE_CPU_X64)
+EFI_STATUS
+EFIAPI
+HypervisorSetSegmentBase (
+  IN  UINTN         Reg,
+  IN  UINTN         Value
+  );
+#endif
+
+/**
+  Hypercall #26: HYPERVISOR_MMUEXT_OP
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorMmuextOp (
+  IN  MMUEXT_OP     *Op,
+  IN  UINTN         Count,
+  OUT UINTN         *SuccessCount,
+  IN  DOMID         DomId
+  );
+
+/**
+  Hypercall #27: HYPERVISOR_XSM_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorXsmOp (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #28: HYPERVISOR_NMI_OP
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorNmiOp (
+  IN  UINTN         Cmd,
+  IN  UINTN         Arg
+  );
+
+/**
+  Hypercall #29: HYPERVISOR_SCHED_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorSchedOp (
+  IN UINTN          Cmd,
+  IN VOID           *Arg
+  );
+
+/**
+  Hypercall #29-2: HYPERVISOR_SCHED_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorSuspend (
+  IN UINTN      Srec
+  );
+
+/**
+  Hypercall #30: HYPERVISOR_CALLBACK_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorCallbackOp (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #31: HYPERVISOR_XENOPROF_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorXenoprofOp (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #32: HYPERVISOR_EVENT_CHANNEL_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorEventChannelOp (
+  IN UINTN     Cmd,
+  IN VOID      *Arg
+  );
+
+/**
+  Hypercall #33: HYPERVISOR_PHYSDEV_OP 
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorPhysdevOp (
+  IN VOID       *Arg
+  );
+
+/**
+  Hypercall #34: HYPERVISOR_HVM_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorHvmOp (
+  IN UINTN      Cmd,
+  IN VOID       *Arg
+  );
+
+/**
+  Hypercall #35: HYPERVISOR_SYSCTL
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorSysctl (
+  IN UINTN      Op
+  );
+
+/**
+  Hypercall #36: HYPERVISOR_DOMCTL
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorDomctl (
+  IN UINTN      Op
+  );
+
+/**
+  Hypercall #37: HYPERVISOR_KEXEC_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorKexecOp (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #38: HYPERVISOR_TMEM_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorTmemOp (
+  //TODO Add parameters
+  );
+
+//
+// Architecture-specific hypercall definitions.
+//
+/**
+  Hypercall #48: HYPERVISOR_ARCH_0
+**/
+EFI_STATUS
+EFIAPI
+HypervisorArch0 (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #49: HYPERVISOR_ARCH_1
+**/
+EFI_STATUS
+EFIAPI
+HypervisorArch1 (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #50: HYPERVISOR_ARCH_2
+**/
+EFI_STATUS
+EFIAPI
+HypervisorArch2 (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #51: HYPERVISOR_ARCH_3
+**/
+EFI_STATUS
+EFIAPI
+HypervisorArch3 (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #52: HYPERVISOR_ARCH_4
+**/
+EFI_STATUS
+EFIAPI
+HypervisorArch4 (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #53: HYPERVISOR_ARCH_5
+**/
+EFI_STATUS
+EFIAPI
+HypervisorArch5 (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #54: HYPERVISOR_ARCH_6
+**/
+EFI_STATUS
+EFIAPI
+HypervisorArch6 (
+  //TODO Add parameters
+  );
+
+/**
+  Hypercall #55: HYPERVISOR_ARCH_7
+**/
+EFI_STATUS
+EFIAPI
+HypervisorArch7 (
+  //TODO Add parameters
+  );
+
+/**
+  Initialize the hypercalls: Get Xen Hypercall page from HOB.
+  
+  @param[out]   A pointer to hypercall page.
+
+**/
+VOID *
+InitializeHypercallPage (
+  VOID
+  );
+
+#endif  //__XEN_HYPERCALL_LIB__
+
Index: OvmfPkg/Library/XenLib/XenLib.c
===================================================================
--- OvmfPkg/Library/XenLib/XenLib.c	(revision 0)
+++ OvmfPkg/Library/XenLib/XenLib.c	(revision 0)
@@ -0,0 +1,82 @@
+/**@file
+  This file holds the common functions used by xen paravirtualization.
+
+  Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include "XenLib.h"
+
+/**
+  Get shared info page.
+
+  @return A pointer to shared info page.
+
+**/
+VOID *
+EFIAPI
+GetSharedInfo (
+  VOID
+  )
+{
+  static EFI_XEN_SHARED_INFO         *SharedInfoPtr = NULL;
+  XEN_ADD_TO_PHYSMAP                 AddPhysmap;
+
+  if (SharedInfoPtr != NULL) {
+    return (VOID *) SharedInfoPtr;
+  }
+
+  AddPhysmap.DomId  = DOMID_SELF; 
+  AddPhysmap.Space  = XENMAPSPACE_SHARED_INFO;
+  AddPhysmap.Index  = 0;
+
+  SharedInfoPtr   = (EFI_XEN_SHARED_INFO *) AllocatePages (EFI_PAGE_SIZE);
+  AddPhysmap.Gpfn = (UINTN)(SharedInfoPtr) >> EFI_PAGE_SHIFT;
+
+  if (HypervisorMemoryOp(XENMEM_ADD_TO_PHYSMAP, &AddPhysmap)) {
+    DEBUG ((EFI_D_ERROR, "Hypercall Error: can't get shared info page.\n"));
+    return NULL;
+  }
+
+  return (VOID *) SharedInfoPtr;
+}
+
+/**
+  Test and clear one bit at a gavin address.
+  TODO The method needs to be written as a assembly function.
+
+  @param IN BitNum   The number of bit to operate.
+  @param IN Addr     The address to operate.
+
+  @return  The old value of the bit.
+
+**/
+UINTN
+EFIAPI
+SyncTestClearBit (
+  IN     UINTN                    BitNum,
+  IN     VOID                     *Addr
+  )
+{
+  UINTN             OldBit;
+
+  __asm__ __volatile__ (
+    "lock          \n\t"
+    "btr  %2,  %1  \n\t"
+    "sbb  %0,  %0  \n\t"
+    : "=r" (OldBit), "=m" (*(volatile long *)Addr)
+    : "Ir" (BitNum), "m" (*(volatile long *)Addr) 
+    : "memory"
+    );
+
+  return OldBit;
+}
+
Index: OvmfPkg/Library/XenLib/XenBus.c
===================================================================
--- OvmfPkg/Library/XenLib/XenBus.c	(revision 0)
+++ OvmfPkg/Library/XenLib/XenBus.c	(revision 0)
@@ -0,0 +1,514 @@
+/**@file
+  This file holds the Xenbus methods, which can setup Xenbus, write and read xenstore entry.
+  Before all the Xenbus operations, XenbusSetup() should execute firstly. 
+  Don't forget to close the Xenbus using XenbusShutdown() after the all the operations done.
+
+  Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include "XenLib.h"
+
+//
+// Shared ring with Domain0
+//
+EFI_XENSTORE_DOMAIN_INTERFACE    *Rings = NULL;
+//
+// Event channel to Domain0
+//
+EFI_EVENT_CHANNEL_PORT            Event;
+static CHAR8                      Payload[XENSTORE_PAYLOAD_MAX + 1];
+static CHAR8                      *PayloadPtr[XENSTORE_PAYLOAD_MAX + 1];
+
+
+/**
+  Helper functions: print a string.
+**/
+UINTN
+EFIAPI
+PrintStr (
+  IN      CONST CHAR8               *FirstString,
+  IN      UINTN                     Length
+  )
+{
+  ASSERT (AsciiStrSize (FirstString));
+
+  while ((*FirstString != '\0') && (Length > 0)) {
+    DEBUG ((EFI_D_INFO, "%c", *FirstString));
+    FirstString++;
+    Length--;
+  }
+
+  DEBUG ((EFI_D_INFO, "\n"));
+  return EFI_SUCCESS;
+}
+
+/**
+  Connect to the backend Xenbus daemon. 
+  This method must be called first before any Xenbus operation.
+
+  @return              EFI_STATUS.
+
+**/
+EFI_STATUS
+EFIAPI
+XenbusSetup (
+  VOID
+  )
+{
+  EFI_XEN_HVM_PARAM  Param;
+
+  //
+  // Get Xenbus shared page.
+  //
+  Param.DomId = DOMID_SELF;
+  Param.Index = HVM_PARAM_STORE_PFN;
+  if ( HypervisorHvmOp(HVMOP_GET_PARAM, &Param) ) {
+    DEBUG ((EFI_D_ERROR, "Hypercall Error: can't get xenbus shared page.\n"));
+  }
+  Rings = (VOID *)(UINTN)(Param.Value << EFI_PAGE_SHIFT);
+
+  //
+  // Get Xenbus event channel.
+  //
+  Param.DomId = DOMID_SELF;
+  Param.Index = HVM_PARAM_STORE_EVTCHN;
+  if ( HypervisorHvmOp(HVMOP_GET_PARAM, &Param) ) {
+    DEBUG ((EFI_D_ERROR, "Hypercall Error: can't get xenbus event channel.\n"));
+  }
+  Event = Param.Value;
+
+  DEBUG ((EFI_D_INFO, "Xenbus rings @0x%x, event channel %d\n", (UINTN) Rings, (UINTN) Event));
+  return EFI_SUCCESS;
+}
+
+/**
+  Reset the Xenbus connection.
+
+  @return              EFI_STATUS.
+
+**/
+EFI_STATUS
+EFIAPI
+XenbusShutdown (
+  VOID
+  )
+{
+  ASSERT(Rings);
+
+  //
+  // Clear the shared ring.
+  //
+  ZeroMem (Rings, sizeof (EFI_XENSTORE_DOMAIN_INTERFACE));  
+
+  //
+  // Clear the event channel state
+  //
+  ZeroMem(GetSharedInfo (), sizeof (EFI_XEN_SHARED_INFO));
+
+  Rings = NULL;
+  return EFI_SUCCESS;
+}
+
+/**
+  Shared Ring operation methods.
+**/
+VOID
+EFIAPI
+RingWait (
+  VOID
+  )
+{
+  EFI_XEN_SHARED_INFO      *SharedInfoPtr;
+  SCHED_POLL               Poll;
+
+  SharedInfoPtr = (EFI_XEN_SHARED_INFO *) GetSharedInfo ();
+
+  ZeroMem (&Poll, sizeof (SCHED_POLL));
+  Poll.Ports.Ptr = &Event;
+  Poll.NrPorts   = 1;
+
+  while ( !SyncTestClearBit(Event, SharedInfoPtr->EventChannelPending) ) {
+    HypervisorSchedOp (SCHEDOP_POLL, &Poll);
+  }
+}
+
+/**
+  Copy data in and out of the ring.
+
+  @param IN Data      The data to write into the shared ring.
+  @param IN Length    The length of the data.
+
+**/
+VOID
+EFIAPI
+RingWrite (
+  IN     CHAR8                    *Data,
+  IN     UINTN                    Length
+  )
+{
+  UINT32           TotleOff;
+  UINT32           RingIndex;
+
+  //
+  // Check the parameters
+  //
+  ASSERT(Length <= XENSTORE_PAYLOAD_MAX);
+
+  RingIndex = XENSTORE_RING_SIZE - 1;
+  while (Length) {
+    //
+    // Keep don't overrun the consumer pointer.
+    //
+    while ((TotleOff = RingIndex - ((Rings->ReqProd - Rings->ReqCons) & RingIndex)) == 0) {
+      RingWait();
+    }
+
+    //
+    // Keep don't overrun the end of the shared ring.
+    //
+    if (TotleOff > (XENSTORE_RING_SIZE - (Rings->ReqProd & RingIndex))) {
+      TotleOff = XENSTORE_RING_SIZE - (Rings->ReqProd & RingIndex);
+    }
+
+    if (TotleOff > Length) {
+      TotleOff = Length;
+    }
+
+    //
+    // Copy the request data to the ring.
+    //
+    CopyMem (
+      Rings->Req + (Rings->ReqProd & RingIndex),
+      Data,
+      TotleOff
+      );
+    MemoryFence();
+    Rings->ReqProd += TotleOff;
+    Length -= TotleOff;
+  }
+}
+
+/**
+  Copy data in and out of the ring.
+
+  @param OUT Data      The data read from the shared ring.
+  @param OUT Length    The length of the data.
+
+**/
+VOID
+EFIAPI
+RingRead (
+  OUT    CHAR8                    *Data,
+  OUT    UINTN                    Length
+  )
+{
+  UINT32           TotleOff;
+  UINT32           RingIndex;
+
+  //
+  // Check the parameters
+  //
+  ASSERT(Length <= XENSTORE_PAYLOAD_MAX);
+
+  RingIndex = XENSTORE_RING_SIZE - 1;
+  while (Length) {
+    //
+    // Keep don't overrun the productor pointer.
+    //
+    while ((TotleOff = ((Rings->RspProd - Rings->RspCons) & RingIndex)) == 0) {
+      RingWait();
+    }
+
+    //
+    // Keep don't overrun the end of the shared ring.
+    //
+    if (TotleOff > (XENSTORE_RING_SIZE - (Rings->RspCons & RingIndex))) {
+      TotleOff = XENSTORE_RING_SIZE - (Rings->RspCons & RingIndex);
+    }
+
+    if (TotleOff > Length) {
+      TotleOff = Length;
+    }
+
+    //
+    // Copy the reply data from the ring.
+    //
+    CopyMem (
+      Data,
+      Rings->Rsp + (Rings->RspCons & RingIndex),
+      TotleOff
+      );
+    MemoryFence();
+    Rings->RspCons += TotleOff;
+    Length -= TotleOff;
+  }
+}
+
+/**
+  Send and receive the request to and from the ring.
+
+  @param IN  Type            The operation type of Xenstore.
+  @param IN  Request         The requests need to send through shared ring.
+  @param IN  ReqNum          The number of the requests.
+  @param OUT ReplyLength     The length of reply data.
+  @param OUT ReplyData       The reply data.
+
+  @return EFI_SUCCESS        Successly.
+  @return Other              Error.
+
+**/
+EFI_STATUS
+EFIAPI
+XenbusMsgReply (
+  IN     EFI_XENSTORE_MSG_TYPE    Type,
+  IN     EFI_XENSTORE_REQUEST     *Request,
+  IN     UINTN                    ReqNum,
+  OUT    UINTN                    *ReplyLength,
+  OUT    CHAR8                    **ReplyData
+  )
+{
+  EFI_XENSTORE_MSG              XenstoreMsg;
+  EVENT_CHANNEL_SEND            Send;
+  UINTN                         Index;
+  UINTN                         Length;
+
+  //
+  // Check the shared ring.
+  //
+  ASSERT(Rings);
+
+  Length = 0;
+  for (Index = 0; Index < ReqNum; Index++) {
+    Length += Request[Index].Length;
+  }
+
+  //
+  // Put the request on the shared ring.
+  //
+  XenstoreMsg.Type              = Type;
+  XenstoreMsg.RequestId         = 0;
+  XenstoreMsg.TransactionId     = 0;
+  XenstoreMsg.Length            = Length;
+
+  RingWrite ((CHAR8 *) &XenstoreMsg, sizeof (EFI_XENSTORE_MSG));
+  for (Index = 0; Index < ReqNum; Index++) {
+    RingWrite (Request[Index].Data, Request[Index].Length);
+  }
+
+  //
+  // Tell Xen (Dom0) about the request.
+  //
+  Send.Port = Event;
+  HypervisorEventChannelOp(EVTCHNOP_SEND, &Send);
+
+  //
+  // Get the reply from the ring.
+  //
+  RingRead ((CHAR8 *) &XenstoreMsg, sizeof (EFI_XENSTORE_MSG));
+  RingRead (Payload, XenstoreMsg.Length);
+  Payload[XenstoreMsg.Length] = '\0';
+
+  if (XenstoreMsg.Type == XSError) {
+    //
+    // If error, there is a Xen error message in Payload.
+    //
+    DEBUG ((EFI_D_ERROR, "Error from Xen shared ring. Error Message: "));
+    PrintStr(Payload, XenstoreMsg.Length);
+
+    *ReplyData    = NULL;
+    *ReplyLength  = 0;
+    return EFI_ABORTED;
+  }
+
+  *ReplyData    = Payload;
+  *ReplyLength  = XenstoreMsg.Length;
+
+  return EFI_SUCCESS;
+}
+
+/**
+  Read a Xenstore key. Returns a nul-terminated string or NULL.
+
+  @param IN  Path            The Xenstore key path.
+  @param OUT Data            The value to of the key.
+
+  @return EFI_SUCCESS        Successly.
+  @return Other              Error.
+
+**/
+EFI_STATUS
+EFIAPI
+XenbusRead (
+  IN     CHAR8                    *Path,
+  OUT    CHAR8                    **Data
+  )
+{
+  EFI_STATUS                    Status;
+  UINTN                         ReplyLength;
+  CHAR8                         *ReplyData;
+
+  EFI_XENSTORE_REQUEST Request[] = {
+    //
+    // Path info
+    //
+    {
+      Path,
+      AsciiStrLen (Path) + 1
+    }
+  };
+
+  //
+  // Send request and get the reply. 
+  //
+  Status = XenbusMsgReply (XSRead, Request, ARRAY_SIZE(Request), &ReplyLength, &ReplyData);
+
+  if (EFI_ERROR(Status)) {
+    return Status;
+  }
+
+  *Data = ReplyData;
+  return EFI_SUCCESS;
+}
+
+/**
+  Create or modify a Xenstore key.
+
+  @param IN  Path            The Xenstore key path.
+  @param IN  Data            The value to of the key.
+
+  @return EFI_SUCCESS        Successly.
+  @return Other              Error.
+
+**/
+EFI_STATUS
+EFIAPI
+XenbusWrite (
+  IN     CHAR8                    *Path,
+  IN     CHAR8                    *Data
+  )
+{
+  EFI_STATUS                    Status;
+  UINTN                         ReplyLength;
+  CHAR8                         *ReplyData;
+
+  EFI_XENSTORE_REQUEST Request[] = {
+    //
+    // Path info
+    //
+    {
+      Path,
+      AsciiStrLen (Path) + 1
+    },
+    //
+    // Value info
+    //
+    {
+      Data,
+      AsciiStrLen (Data) + 1
+    }
+  };
+
+  //
+  // Send request and get the reply. 
+  //
+  Status = XenbusMsgReply (XSWrite, Request, ARRAY_SIZE(Request), &ReplyLength, &ReplyData);
+
+  if (EFI_ERROR(Status)) {
+    return Status;
+  }
+
+  return EFI_SUCCESS;
+}
+
+/**
+  List a Xenstore directory.
+
+  @param IN  Path            The Xenstore key path.
+  @param OUT DataArray       A array of pointers to the key under the directory.
+
+  @return EFI_SUCCESS        Successly.
+  @return Other              Error.
+
+**/
+EFI_STATUS
+EFIAPI
+XenbusLs (
+  IN     CHAR8                    *Path,
+  OUT    CHAR8                    ***DataArray
+  )
+{
+  EFI_STATUS                    Status;
+  UINTN                         ReplyLength;
+  CHAR8                         *ReplyData;
+  UINTN                         Index;
+  CHAR8                         *StrStart;
+  UINTN                         KeyNum;
+
+  EFI_XENSTORE_REQUEST Request[] = {
+    //
+    // Path info
+    //
+    {
+      Path,
+      AsciiStrLen (Path) + 1
+    }
+  };
+
+  //
+  // Send request and get the reply. 
+  //
+  Status = XenbusMsgReply (XSDirectory, Request, ARRAY_SIZE(Request), &ReplyLength, &ReplyData);
+
+  if (EFI_ERROR(Status)) {
+    return Status;
+  }
+
+  //
+  // Split out each key
+  //
+  KeyNum   = 0;
+  StrStart = ReplyData;
+  for (Index = 0; Index < ReplyLength; Index++) {
+    if (ReplyData[Index] == '\0') {
+      PayloadPtr[KeyNum++] = StrStart;
+      StrStart = (CHAR8 *) (ReplyData + Index + 1);
+    }
+  }
+
+  *DataArray = PayloadPtr;
+  return EFI_SUCCESS;
+}
+
+/**
+  Get domain ID from xenstore.
+
+  @return  The ID of surrent Domain.
+
+**/
+DOMID
+EFIAPI
+XenbusGetDomId (
+  VOID
+  )
+{
+  EFI_STATUS                    Status;
+  CHAR8                         *Data;
+
+  Status = XenbusRead("domid", &Data);
+
+  if (EFI_ERROR(Status)) {
+    return -1;
+  }
+  
+  return (DOMID) AsciiStrDecimalToUintn(Data);
+}
+
Index: OvmfPkg/Library/XenLib/XenLib.h
===================================================================
--- OvmfPkg/Library/XenLib/XenLib.h	(revision 0)
+++ OvmfPkg/Library/XenLib/XenLib.h	(revision 0)
@@ -0,0 +1,31 @@
+/**@file
+  Xenbus library.
+
+  Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#ifndef _XEN_LIB_H_
+#define _XEN_LIB_H_
+
+#include <PiDxe.h>
+
+#include <Library/MemoryAllocationLib.h>
+#include <Library/BaseMemoryLib.h>
+#include <Library/BaseLib.h>
+#include <Library/DebugLib.h>
+#include <Guid/XenInfo.h>
+
+#include <Library/XenHypercallLib.h>
+#include <Library/XenLib.h>
+
+#endif
+
Index: OvmfPkg/Library/XenLib/XenLib.inf
===================================================================
--- OvmfPkg/Library/XenLib/XenLib.inf	(revision 0)
+++ OvmfPkg/Library/XenLib/XenLib.inf	(revision 0)
@@ -0,0 +1,44 @@
+## @file
+#  Component description file for Xenbus Library module.
+#
+#  Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution.  The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php
+#
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = XenLib
+  FILE_GUID                      = 62c85c20-5b0e-4937-9fc3-448370a60d04
+  MODULE_TYPE                    = BASE
+  VERSION_STRING                 = 1.0
+  LIBRARY_CLASS                  = XenLib|DXE_DRIVER DXE_RUNTIME_DRIVER DXE_SAL_DRIVER UEFI_DRIVER
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64 IPF
+#
+
+[Sources]
+  XenLib.h
+  XenLib.c
+  XenBus.c
+
+[Packages]
+  MdePkg/MdePkg.dec
+  OvmfPkg/OvmfPkg.dec
+
+[LibraryClasses]
+  MemoryAllocationLib
+  BaseMemoryLib
+  BaseLib
+  DebugLib
+
Index: OvmfPkg/Library/XenHypercallLib/XenHypercallLib.inf
===================================================================
--- OvmfPkg/Library/XenHypercallLib/XenHypercallLib.inf	(revision 0)
+++ OvmfPkg/Library/XenHypercallLib/XenHypercallLib.inf	(revision 0)
@@ -0,0 +1,56 @@
+## @file
+#  Component description file for Xen Hypercall Library module.
+#
+#  Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+#
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution. The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = XenHypercallLib
+  FILE_GUID                      = 0a5baf88-b6ec-4338-b1a7-f1496f605359
+  MODULE_TYPE                    = UEFI_DRIVER
+  VERSION_STRING                 = 1.0
+
+  LIBRARY_CLASS                  = XenHypercallLib|DXE_DRIVER DXE_RUNTIME_DRIVER DXE_SAL_DRIVER UEFI_DRIVER
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64 IPF EBC
+#
+
+[Sources]
+  GasketHypercall.h
+  XenHypercallLib.h
+  XenHypercallLib.c
+  Hypercall.c
+
+[Sources.X64]
+  X64/GasketHypercall.S   # convert between Emu x86_64 ABI and EFI X64 ABI
+
+[Sources.IA32]
+  Ia32/GasketHypercall.S  #
+
+
+[Packages]
+  MdePkg/MdePkg.dec
+  OvmfPkg/OvmfPkg.dec
+
+[LibraryClasses]
+  DebugLib
+  HobLib
+
+[Guids]
+  gEfiXenInfoGuid                      # PROTOCOL ALWAYS_CONSUMED
+
+[Depex]
+  TRUE
Index: OvmfPkg/Library/XenHypercallLib/X64/GasketHypercall.S
===================================================================
--- OvmfPkg/Library/XenHypercallLib/X64/GasketHypercall.S	(revision 0)
+++ OvmfPkg/Library/XenHypercallLib/X64/GasketHypercall.S	(revision 0)
@@ -0,0 +1,93 @@
+#------------------------------------------------------------------------------
+#
+# Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+#
+# This program and the accompanying materials
+# are licensed and made available under the terms and conditions of the BSD License
+# which accompanies this distribution.  The full text of the license may be found at
+# http://opensource.org/licenses/bsd-license.php.
+#
+# THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+# WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+# Module Name:
+#
+#   GasketHypercall.S
+#
+# Abstract:
+#
+#   Hypercall function
+#
+# Notes:
+#
+#------------------------------------------------------------------------------
+
+#------------------------------------------------------------------------------
+#  UINTN
+#  EFIAPI
+#  Hypercall (
+#    IN  VOID   *HypercallPageAddress,  // passed in %rcx
+#    IN  UINTN  HypercallOffset,        // passed in %rdx
+#    IN  UINTN  Arg1,                   // passed in %r8
+#    IN  UINTN  Arg2,                   // passed in %r9
+#    IN  UINTN  Arg3,                   // passed in stack
+#    IN  UINTN  Arg4,                   // passed in stack
+#    IN  UINTN  Arg5,                   // passed in stack
+#    )
+#------------------------------------------------------------------------------
+
+  .text
+
+ASM_GLOBAL ASM_PFX(Hypercall)
+ASM_PFX(Hypercall):
+  pushq   %rbp            // stack frame is for the debugger
+  movq    %rsp, %rbp
+  subq    $16, %rsp       // Allocate space for args on the stack
+
+  pushq   %rsi            // %rsi & %rdi are callee-save in EFI ABI
+  pushq   %rdi
+
+  movq    %rcx, %rax      // Swizzle args
+  addq    %rdx, %rax      // Address of hypercall is in %rax
+
+  movq    %r8,  %rdi      // Move parameters into %rdi,
+  movq    %r9,  %rsi      // %rsi,
+  movq    48(%rbp), %rdx  // %rdx,
+  movq    56(%rbp), %r10  // %r10,
+  movq    64(%rbp), %r8   // %r8
+  movq    %r8,     (%rsp) //
+
+  call    *%rax
+  addq    $16, %rsp
+
+  popq    %rdi            // restore state
+  popq    %rsi
+  popq    %rbp
+  ret                     // return value is in %rax
+
+
+//
+// Hypercall2 is not used.
+//
+ASM_GLOBAL ASM_PFX(Hypercall2)
+ASM_PFX(Hypercall2):
+  pushq   %rbp            // stack frame is for the debugger
+  movq    %rsp, %rbp
+
+  pushq   %rsi            // %rsi & %rdi are callee-save in EFI ABI
+  pushq   %rdi
+
+  movq    %rcx, %rax      // Swizzle args
+  addq    %rdx, %rax      // Address of hypercall is in %rax
+
+  movq    %r8,  %rdi      // Move parameters into %rdi, %rsi
+  movq    %r9,  %rsi
+
+  call    *%rax
+
+  popq    %rdi            // restore state
+  popq    %rsi
+  popq    %rbp
+  ret                     // return value is in %rax
+
+
Index: OvmfPkg/Library/XenHypercallLib/Hypercall.c
===================================================================
--- OvmfPkg/Library/XenHypercallLib/Hypercall.c	(revision 0)
+++ OvmfPkg/Library/XenHypercallLib/Hypercall.c	(revision 0)
@@ -0,0 +1,544 @@
+/**@file
+  This file holds all the needed Xen Hypercalls.
+
+  Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include "XenHypercallLib.h"
+
+/**
+  This method passes the hypercall parameters and hypercall number to UNIX ABI function, as well as the address of hypercall page.
+
+  @param  HypercallNum    The Number of the hypercall.
+  @param  Arg1-Arg5       Parameters for the hypercall.
+
+**/
+EFI_STATUS
+EFIAPI
+Hypercall2Abi (
+  IN  UINTN  HypercallNum,
+  IN  UINTN  Arg1,
+  IN  UINTN  Arg2,
+  IN  UINTN  Arg3,
+  IN  UINTN  Arg4,
+  IN  UINTN  Arg5
+  )
+{
+  VOID *HypercallPages;
+
+  HypercallPages = InitializeHypercallPage ();
+  if (HypercallPages == NULL) {
+    return 0;
+  }
+
+  //
+  // All the hypercalls call this function.
+  //
+  return Hypercall (HypercallPages, HypercallNum * 32, Arg1, Arg2, Arg3, Arg4, Arg5);
+}
+
+/**
+  Xen Hypercall. All the hypercalls call one function.
+
+  @param  Cmd       parameter.
+  @param  Arg       Parameter.
+
+**/
+
+/**
+  Hypercall #0: HYPERVISOR_SET_TRAP_TABLE
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorSetTrapTable (
+  IN OUT TRAP_INFO     *Table
+  )
+{
+  return Hypercall2Abi (HYPERVISOR_SET_TRAP_TABLE, (UINTN) Table, 0, 0, 0, 0);
+}
+
+/**
+  Hypercall #1: HYPERVISOR_MMU_UPDATE
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorMmuUpdate (
+  IN  MMU_UPDATE    *Req,
+  IN  UINTN         Count,
+  OUT UINTN         *SuccessCount,
+  IN  DOMID         DomId
+  )
+{
+  return Hypercall2Abi (HYPERVISOR_MMU_UPDATE, (UINTN) Req, (UINTN) Count, (UINTN) SuccessCount, (UINTN) DomId, 0);
+}
+
+/**
+  Hypercall #2: HYPERVISOR_SET_GDT
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorSetGdt (
+  IN  UINTN         *FrameList,
+  IN  UINTN         Entries
+  )
+{
+  return Hypercall2Abi (HYPERVISOR_SET_GDT, (UINTN) FrameList, (UINTN) Entries, 0, 0, 0);
+}
+
+/**
+  Hypercall #3: HYPERVISOR_STACK_SWITCH
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorStackSwitch (
+  IN  UINTN         SS,
+  IN  UINTN         Esp
+  )
+{
+  return Hypercall2Abi (HYPERVISOR_STACK_SWITCH, (UINTN) SS, (UINTN) Esp, 0, 0, 0);
+}
+
+/**
+  Hypercall #4: HYPERVISOR_SET_CALLBACKS
+  TODO Untested
+**/
+#if   defined (MDE_CPU_IA32)
+EFI_STATUS
+EFIAPI
+HypervisorSetCallbacks (
+  IN  UINTN         EventSelector,
+  IN  UINTN         EventAddress,
+  IN  UINTN         FailsafeSelector,
+  IN  UINTN         FailsafeAddress
+  )
+{
+  return Hypercall2Abi (HYPERVISOR_SET_CALLBACKS, (UINTN) EventSelector, (UINTN) EventAddress, (UINTN) FailsafeSelector, (UINTN) FailsafeAddress, 0);
+}
+#endif
+
+#if defined (MDE_CPU_X64)
+EFI_STATUS
+EFIAPI
+HypervisorSetCallbacks (
+  IN  UINTN         EventAddress,
+  IN  UINTN         FailsafeAddress,
+  IN  UINTN         SyscallAddress
+  )
+{
+  return Hypercall2Abi (HYPERVISOR_SET_CALLBACKS, (UINTN) EventAddress, (UINTN) FailsafeAddress, (UINTN) SyscallAddress, 0, 0);
+}
+#endif
+
+/**
+  Hypercall #5: HYPERVISOR_FPU_TASKSWITCH
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorFpuTaskswitch (
+  IN  UINTN         Set
+  )
+{
+  return Hypercall2Abi (HYPERVISOR_FPU_TASKSWITCH, (UINTN) Set, 0, 0, 0, 0);
+}
+
+/**
+  Hypercall #8: HYPERVISOR_SET_DEBUGREG
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorSetDebugreg (
+  IN  UINTN         Reg,
+  IN  UINTN         Value
+  )
+{
+  return Hypercall2Abi (HYPERVISOR_SET_DEBUGREG, (UINTN) Reg, (UINTN) Value, 0, 0, 0);
+}
+
+/**
+  Hypercall #9: HYPERVISOR_GET_DEBUGREG
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorGetDebugreg (
+  IN  UINTN         Reg
+  )
+{
+  return Hypercall2Abi (HYPERVISOR_GET_DEBUGREG, (UINTN) Reg, 0, 0, 0, 0);
+}
+
+/**
+  Hypercall #10: HYPERVISOR_UPDATE_DESCRIPTOR
+  TODO Untested
+**/
+#if   defined (MDE_CPU_IA32)
+EFI_STATUS
+EFIAPI
+HypervisorUpdateDescriptor (
+  IN  UINT64        Ma,
+  IN  UINT64         Desc
+  )
+{
+  return Hypercall2Abi (HYPERVISOR_UPDATE_DESCRIPTOR, (UINTN) Ma, (UINTN) (Ma >> 32), (UINTN) Desc, (UINTN) (Desc >> 32), 0);
+}
+#endif
+
+#if defined (MDE_CPU_X64)
+EFI_STATUS
+EFIAPI
+HypervisorUpdateDescriptor (
+  IN  UINTN         Ma,
+  IN  UINTN         Word
+  )
+{
+  return Hypercall2Abi (HYPERVISOR_UPDATE_DESCRIPTOR, (UINTN) Ma, (UINTN) Word, 0, 0, 0);
+}
+#endif
+
+/**
+  Hypercall #12: HYPERVISOR_MEMORY_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorMemoryOp (
+  IN UINTN      Cmd,
+  IN VOID       *Arg
+  )
+{
+  return Hypercall2Abi (HYPERVISOR_MEMORY_OP, (UINTN) Cmd, (UINTN) Arg, 0, 0, 0);
+}
+
+/**
+  Hypercall #13: HYPERVISOR_MULTICALL
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorMulticall (
+  IN  VOID          *CallList,
+  IN  UINTN         NrCalls
+  )
+{
+  return Hypercall2Abi (HYPERVISOR_MULTICALL, (UINTN) CallList, (UINTN) NrCalls, 0, 0, 0);
+}
+
+/**
+  Hypercall #14: HYPERVISOR_UPDATE_VA_MAPPING
+  TODO Untested
+**/
+#if   defined (MDE_CPU_IA32)
+EFI_STATUS
+EFIAPI
+HypervisorUpdateVaMapping (
+  IN  UINTN         Va,
+  IN  PTE           NewVal,
+  IN  UINTN         Flags
+  )
+{
+  return Hypercall2Abi (HYPERVISOR_UPDATE_VA_MAPPING, (UINTN) Va, (UINTN) NewVal.PteLow, (UINTN) NewVal.PteHigh, (UINTN) Flags, 0);
+}
+#endif
+
+#if defined (MDE_CPU_X64)
+EFI_STATUS
+EFIAPI
+HypervisorUpdateVaMapping (
+  IN  UINTN         Va,
+  IN  PTE           NewVal,
+  IN  UINTN         Flags
+  )
+{
+  return Hypercall2Abi (HYPERVISOR_UPDATE_VA_MAPPING, (UINTN) Va, (UINTN) NewVal.Pte, (UINTN) Flags, 0, 0);
+}
+#endif
+
+/**
+  Hypercall #15: HYPERVISOR_SET_TIMER_OP
+  TODO Untested
+**/
+#if   defined (MDE_CPU_IA32)
+EFI_STATUS
+EFIAPI
+HypervisorSetTimerOp (
+  IN UINT64     Timeout
+  )
+{
+  UINTN    TimeoutHi;
+  UINTN    TimeoutLo;
+
+  TimeoutHi = (UINTN) (Timeout >> 32);
+  TimeoutLo = (UINTN) Timeout;
+  return Hypercall2Abi (HYPERVISOR_SET_TIMER_OP, (UINTN) TimeoutHi, (UINTN) TimeoutLo, 0, 0, 0);
+}
+#endif
+
+#if defined (MDE_CPU_X64)
+EFI_STATUS
+EFIAPI
+HypervisorSetTimerOp (
+  IN UINT64     Timeout
+  )
+{
+  return Hypercall2Abi (HYPERVISOR_SET_TIMER_OP, (UINTN) Timeout, 0, 0, 0, 0);
+}
+#endif
+
+/**
+  Hypercall #17: HYPERVISOR_XEN_VERSION
+**/
+EFI_STATUS
+EFIAPI
+HypervisorXenVersion (
+  IN UINTN      Cmd,
+  IN VOID       *Arg
+  )
+{
+  return Hypercall2Abi (HYPERVISOR_XEN_VERSION, (UINTN) Cmd, (UINTN) Arg, 0, 0, 0);
+}
+
+/**
+  Hypercall #18: HYPERVISOR_CONSOLE_IO
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorConsoleIo (
+  IN  UINTN         Cmd,
+  IN  UINTN         Count,
+  OUT CHAR8         *Str
+  )
+{
+  return Hypercall2Abi (HYPERVISOR_CONSOLE_IO, (UINTN) Cmd, (UINTN) Count, (UINTN) Str, 0, 0);
+}
+
+/**
+  Hypercall #20: HYPERVISOR_GRANT_TABLE_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorGrantTableOp(
+  IN UINTN      Cmd,
+  IN VOID       *Uop,
+  IN UINTN      Count
+)
+{
+  return Hypercall2Abi (HYPERVISOR_GRANT_TABLE_OP, (UINTN) Cmd, (UINTN) Uop, (UINTN) Count, 0, 0);
+}
+
+/**
+  Hypercall #21: HYPERVISOR_VM_ASSIST
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorVmAssist (
+  IN  UINTN         Cmd,
+  IN  UINTN         Type
+  )
+{
+  return Hypercall2Abi(HYPERVISOR_VM_ASSIST, (UINTN) Cmd, (UINTN) Type, 0, 0, 0);
+}
+
+/**
+  Hypercall #22: HYPERVISOR_UPDATE_VA_MAPPING_OTHERDOMAIN
+  TODO Untested
+**/
+#if   defined (MDE_CPU_IA32)
+EFI_STATUS
+EFIAPI
+HypervisorUpdateVaMappingOtherdomain (
+  IN  UINTN         Va,
+  IN  PTE           NewVal,
+  IN  UINTN         Flags,
+  IN  DOMID         DomId
+  )
+{
+  return Hypercall2Abi (HYPERVISOR_UPDATE_VA_MAPPING_OTHERDOMAIN, (UINTN) Va, (UINTN) NewVal.PteLow, (UINTN) NewVal.PteHigh, (UINTN) Flags, (UINTN) DomId);
+}
+#endif
+
+#if defined (MDE_CPU_X64)
+EFI_STATUS
+EFIAPI
+HypervisorUpdateVaMappingOtherdomain (
+  IN  UINTN         Va,
+  IN  PTE           NewVal,
+  IN  UINTN         Flags,
+  IN  DOMID         DomId
+  )
+{
+  return Hypercall2Abi (HYPERVISOR_UPDATE_VA_MAPPING_OTHERDOMAIN, (UINTN) Va, (UINTN) NewVal.Pte, (UINTN) Flags, (UINTN) DomId, 0);
+}
+#endif
+
+/**
+  Hypercall #24: HYPERVISOR_VCPU_OP
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorVcpuOp (
+  IN  UINTN         Cmd,
+  IN  UINTN         VcpuId,
+  IN  VOID          *ExtraArgs
+  )
+{
+  return Hypercall2Abi(HYPERVISOR_VCPU_OP, (UINTN) Cmd, (UINTN) VcpuId, (UINTN) ExtraArgs, 0, 0);
+}
+
+/**
+  Hypercall #25: HYPERVISOR_SET_SEGMENT_BASE
+  TODO Untested
+**/
+#if defined (MDE_CPU_X64)
+EFI_STATUS
+EFIAPI
+HypervisorSetSegmentBase (
+  IN  UINTN         Reg,
+  IN  UINTN         Value
+  )
+{
+  return Hypercall2Abi(HYPERVISOR_SET_SEGMENT_BASE, (UINTN) Reg, (UINTN) Value, 0, 0, 0);
+}
+#endif
+
+/**
+  Hypercall #26: HYPERVISOR_MMUEXT_OP
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorMmuextOp (
+  IN  MMUEXT_OP     *Op,
+  IN  UINTN         Count,
+  OUT UINTN         *SuccessCount,
+  IN  DOMID         DomId
+  )
+{
+  return Hypercall2Abi (HYPERVISOR_MMUEXT_OP, (UINTN) Op, (UINTN) Count, (UINTN) SuccessCount, (UINTN) DomId, 0);
+}
+
+/**
+  Hypercall #28: HYPERVISOR_NMI_OP
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorNmiOp (
+  IN  UINTN         Cmd,
+  IN  UINTN         Arg
+  )
+{
+  return Hypercall2Abi(HYPERVISOR_NMI_OP, (UINTN) Cmd, (UINTN) Arg, 0, 0, 0);
+}
+
+/**
+  Hypercall #29: HYPERVISOR_SCHED_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorSchedOp (
+  IN UINTN      Cmd,
+  IN VOID       *Arg
+  )
+{
+  return Hypercall2Abi(HYPERVISOR_SCHED_OP, (UINTN) Cmd, (UINTN) Arg, 0, 0, 0);
+}
+
+/**
+  Hypercall #29-2: HYPERVISOR_SCHED_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorSuspend (
+  IN UINTN      Srec
+  )
+{
+  return Hypercall2Abi(HYPERVISOR_SCHED_OP, (UINTN) SCHEDOP_SHUTDOWN, (UINTN) SHUTDOWN_SUSPEND, (UINTN) Srec, 0, 0);
+}
+
+/**
+  Hypercall #32: HYPERVISOR_EVENT_CHANNEL_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorEventChannelOp (
+  IN UINTN      Cmd,
+  IN VOID       *Arg
+  )
+{
+  return Hypercall2Abi(HYPERVISOR_EVENT_CHANNEL_OP, (UINTN) Cmd, (UINTN) Arg, 0, 0, 0);
+}
+
+/**
+  Hypercall #33: HYPERVISOR_PHYSDEV_OP 
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorPhysdevOp (
+  IN VOID       *Arg
+  )
+{
+  return Hypercall2Abi(HYPERVISOR_PHYSDEV_OP, (UINTN) Arg, 0, 0, 0, 0);
+}
+
+/**
+  Hypercall #34: HYPERVISOR_HVM_OP
+**/
+EFI_STATUS
+EFIAPI
+HypervisorHvmOp (
+  IN UINTN      Cmd,
+  IN VOID       *Arg
+  )
+{
+  return Hypercall2Abi (HYPERVISOR_HVM_OP, (UINTN) Cmd, (UINTN) Arg, 0, 0, 0);
+}
+
+/**
+  Hypercall #35: HYPERVISOR_SYSCTL
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorSysctl (
+  IN UINTN      Op
+  )
+{
+  return Hypercall2Abi (HYPERVISOR_SYSCTL, (UINTN) Op, 0, 0, 0, 0);
+}
+
+/**
+  Hypercall #36: HYPERVISOR_DOMCTL
+  TODO Untested
+**/
+EFI_STATUS
+EFIAPI
+HypervisorDomctl (
+  IN UINTN      Op
+  )
+{
+  return Hypercall2Abi (HYPERVISOR_DOMCTL, (UINTN) Op, 0, 0, 0, 0);
+}
+
+/*
+  Add more hypercall here
+
+**/
+
Index: OvmfPkg/Library/XenHypercallLib/XenHypercallLib.c
===================================================================
--- OvmfPkg/Library/XenHypercallLib/XenHypercallLib.c	(revision 0)
+++ OvmfPkg/Library/XenHypercallLib/XenHypercallLib.c	(revision 0)
@@ -0,0 +1,43 @@
+/** @file
+Prepare to use Xen Hypercall.
+
+Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+
+This program and the accompanying materials
+are licensed and made available under the terms and conditions of the BSD License
+which accompanies this distribution.  The full text of the license may be found at
+http://opensource.org/licenses/bsd-license.php
+
+THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include "XenHypercallLib.h"
+
+/**
+  Initialize the hypercalls: Get Xen Hypercall page from HOB.
+  
+  @param[out]   A pointer to hypercall page.
+
+**/
+VOID *
+InitializeHypercallPage (
+  VOID
+  )
+{
+  EFI_PEI_HOB_POINTERS  GuidHob;
+  EFI_XEN_INFO          *mXenInfo;
+ 
+  GuidHob.Raw = GetFirstGuidHob (&gEfiXenInfoGuid);
+  if (GuidHob.Raw != NULL) {
+    mXenInfo = GET_GUID_HOB_DATA (GuidHob.Guid);
+    if (mXenInfo != NULL) {
+      return (VOID *) (UINTN) mXenInfo->HyperPages;
+    }
+  } 
+
+  DEBUG ((EFI_D_ERROR, "Gasket_Fail to get Xen info from hob\n"));
+  return NULL;
+}
+
Index: OvmfPkg/Library/XenHypercallLib/GasketHypercall.h
===================================================================
--- OvmfPkg/Library/XenHypercallLib/GasketHypercall.h	(revision 0)
+++ OvmfPkg/Library/XenHypercallLib/GasketHypercall.h	(revision 0)
@@ -0,0 +1,44 @@
+/** @file
+
+  Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#ifndef _GASKET_HYPERCALL_H_
+#define _GASKET_HYPERCALL_H_
+
+UINTN
+EFIAPI
+Hypercall (
+  IN  VOID   *HypercallPageAddress,  // Address of hypercall page
+  IN  UINTN  HypercallOffset,        // Hypercall Offset ( = hypercall num * 32)
+  IN  UINTN  Arg1,                   // parameters
+  IN  UINTN  Arg2,                   //
+  IN  UINTN  Arg3,                   //
+  IN  UINTN  Arg4,                   //
+  IN  UINTN  Arg5                    //
+  );
+
+
+//
+// Hypercall2 is not used!
+//
+UINTN
+EFIAPI
+Hypercall2 (
+  IN  VOID   *HypercallPageAddress,  // Address of hypercall page
+  IN  UINTN  HypercallOffset,        // Hypercall Offset ( = hypercall num * 32)
+  IN  UINTN  Arg1,                   // parameters
+  IN  UINTN  Arg2                    //
+  );
+
+#endif
+
Index: OvmfPkg/Library/XenHypercallLib/XenHypercallLib.h
===================================================================
--- OvmfPkg/Library/XenHypercallLib/XenHypercallLib.h	(revision 0)
+++ OvmfPkg/Library/XenHypercallLib/XenHypercallLib.h	(revision 0)
@@ -0,0 +1,30 @@
+/** @file
+Provide Xen Hypercall.
+
+Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+
+This program and the accompanying materials
+are licensed and made available under the terms and conditions of the BSD License
+which accompanies this distribution.  The full text of the license may be found at
+http://opensource.org/licenses/bsd-license.php
+
+THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#ifndef _XEN_HYPERCALL_LIB_H_
+#define _XEN_HYPERCALL_LIB_H_
+
+#include <PiDxe.h>
+
+#include <Library/HobLib.h>
+#include <Library/DebugLib.h>
+#include <Guid/XenInfo.h>
+
+#include <Library/XenHypercallLib.h>
+#include <Library/XenLib.h>
+#include "GasketHypercall.h"
+
+#endif
+
Index: OvmfPkg/Library/XenHypercallLib/Ia32/GasketHypercall.S
===================================================================
--- OvmfPkg/Library/XenHypercallLib/Ia32/GasketHypercall.S	(revision 0)
+++ OvmfPkg/Library/XenHypercallLib/Ia32/GasketHypercall.S	(revision 0)
@@ -0,0 +1,96 @@
+#------------------------------------------------------------------------------
+#
+# Copyright (c) 2011, Bei Guan <gbtju85@gmail.com>
+#
+# This program and the accompanying materials
+# are licensed and made available under the terms and conditions of the BSD License
+# which accompanies this distribution.  The full text of the license may be found at
+# http://opensource.org/licenses/bsd-license.php.
+#
+# THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+# WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+# Module Name:
+#
+#   GasketHypercall.S
+#
+# Abstract:
+#
+#   Hypercall function
+#
+# Notes:
+#
+#------------------------------------------------------------------------------
+
+#------------------------------------------------------------------------------
+#  UINTN
+#  EFIAPI
+#  Hypercall (
+#    IN  VOID   *HypercallPageAddress,  // passed in stack 8(%ebp)
+#    IN  UINTN  HypercallOffset,        // passed in stack 12(%ebp)
+#    IN  UINTN  Arg1,                   // passed in stack 16(%ebp)
+#    IN  UINTN  Arg2,                   // passed in stack 20(%ebp)
+#    IN  UINTN  Arg3,                   // passed in stack 24(%ebp)
+#    IN  UINTN  Arg4,                   // passed in stack 28(%ebp)
+#    IN  UINTN  Arg5,                   // passed in stack 32(%ebp)
+#    )
+#------------------------------------------------------------------------------
+
+  .text
+
+ASM_GLOBAL ASM_PFX(Hypercall)
+ASM_PFX(Hypercall):
+  pushl %ebp
+  movl  %esp, %ebp
+
+  pushl %ebx
+  pushl %ecx
+  pushl %edx
+  pushl %esi
+  pushl %edi  
+
+  movl 8(%ebp), %eax     // Address of hypercall page
+  addl 12(%ebp), %eax    // Address of hypercall is in %rax
+
+  movl 32(%ebp), %edi    // Swizzle args
+  movl 28(%ebp), %esi
+  movl 24(%ebp), %edx
+  movl 20(%ebp), %ecx
+  movl 16(%ebp), %ebx
+
+  call  *%eax
+
+  popl %edi
+  popl %esi
+  popl %edx
+  popl %ecx
+  popl %ebx
+
+  movl %ebp, %esp
+  popl %ebp
+  ret
+
+
+//
+// Hypercall2 is not used.
+//
+ASM_GLOBAL ASM_PFX(Hypercall2)
+ASM_PFX(Hypercall2):
+  pushl	%ebp
+  movl	%esp, %ebp
+
+  pushl %ecx
+
+  movl 8(%ebp), %eax     // Address of hypercall page
+  addl 12(%ebp), %eax    // Address of hypercall is in %rax
+
+  movl 20(%ebp), %ecx    // Swizzle args
+  movl 16(%ebp), %ebx
+ 
+  call *%eax
+
+  popl %ecx
+  movl %ebp, %esp
+  popl %ebp
+  ret
+
Index: OvmfPkg/OvmfPkgIa32.dsc
===================================================================
--- OvmfPkg/OvmfPkgIa32.dsc	(revision 12124)
+++ OvmfPkg/OvmfPkgIa32.dsc	(working copy)
@@ -79,6 +79,8 @@
   UefiApplicationEntryPoint|MdePkg/Library/UefiApplicationEntryPoint/UefiApplicationEntryPoint.inf
   DevicePathLib|MdePkg/Library/UefiDevicePathLib/UefiDevicePathLib.inf
   NvVarsFileLib|OvmfPkg/Library/NvVarsFileLib/NvVarsFileLib.inf
+  XenHypercallLib|OvmfPkg/Library/XenHypercallLib/XenHypercallLib.inf
+  XenLib|OvmfPkg/Library/XenLib/XenLib.inf
   FileHandleLib|ShellPkg/Library/UefiFileHandleLib/UefiFileHandleLib.inf
   UefiCpuLib|UefiCpuPkg/Library/BaseUefiCpuLib/BaseUefiCpuLib.inf
   SecurityManagementLib|MdeModulePkg/Library/DxeSecurityManagementLib/DxeSecurityManagementLib.inf
@@ -300,9 +302,12 @@
   }
 
   MdeModulePkg/Core/RuntimeDxe/RuntimeDxe.inf
+  #
+  # Xen PV Library Test
+  #
+  OvmfPkg/HypercallTestDxe/HypercallTestDxe.inf
   MdeModulePkg/Universal/SecurityStubDxe/SecurityStubDxe.inf
   MdeModulePkg/Universal/EbcDxe/EbcDxe.inf
-  MdeModulePkg/Universal/SmbiosDxe/SmbiosDxe.inf
   PcAtChipsetPkg/8259InterruptControllerDxe/8259.inf
   UefiCpuPkg/CpuIo2Dxe/CpuIo2Dxe.inf
   UefiCpuPkg/CpuDxe/CpuDxe.inf
@@ -367,10 +372,16 @@
   IntelFrameworkModulePkg/Bus/Isa/IsaFloppyDxe/IsaFloppyDxe.inf
 
   #
+  # SMBIOS Support
+  #
+  MdeModulePkg/Universal/SmbiosDxe/SmbiosDxe.inf
+  OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.inf
+
+  #
   # ACPI Support
   #
   MdeModulePkg/Universal/Acpi/AcpiTableDxe/AcpiTableDxe.inf
-  MdeModulePkg/Universal/Acpi/AcpiPlatformDxe/AcpiPlatformDxe.inf
+  OvmfPkg/AcpiPlatformDxe/AcpiPlatformDxe.inf
   OvmfPkg/AcpiTables/AcpiTables.inf
 
   #
Index: OvmfPkg/OvmfPkgIa32.fdf
===================================================================
--- OvmfPkg/OvmfPkgIa32.fdf	(revision 12124)
+++ OvmfPkg/OvmfPkgIa32.fdf	(working copy)
@@ -150,9 +150,12 @@
 INF  MdeModulePkg/Universal/PCD/Dxe/Pcd.inf
 
 INF  MdeModulePkg/Core/RuntimeDxe/RuntimeDxe.inf
+#
+# Xen PV Library Test
+#
+INF  OvmfPkg/HypercallTestDxe/HypercallTestDxe.inf
 INF  MdeModulePkg/Universal/SecurityStubDxe/SecurityStubDxe.inf
 INF  MdeModulePkg/Universal/EbcDxe/EbcDxe.inf
-INF  MdeModulePkg/Universal/SmbiosDxe/SmbiosDxe.inf
 INF  PcAtChipsetPkg/8259InterruptControllerDxe/8259.inf
 INF  UefiCpuPkg/CpuIo2Dxe/CpuIo2Dxe.inf
 INF  UefiCpuPkg/CpuDxe/CpuDxe.inf
@@ -198,8 +201,11 @@
 INF  IntelFrameworkModulePkg/Bus/Isa/Ps2KeyboardDxe/Ps2keyboardDxe.inf
 INF  IntelFrameworkModulePkg/Bus/Isa/IsaFloppyDxe/IsaFloppyDxe.inf
 
+INF  MdeModulePkg/Universal/SmbiosDxe/SmbiosDxe.inf
+INF  OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.inf
+
 INF  MdeModulePkg/Universal/Acpi/AcpiTableDxe/AcpiTableDxe.inf
-INF  MdeModulePkg/Universal/Acpi/AcpiPlatformDxe/AcpiPlatformDxe.inf
+INF  OvmfPkg/AcpiPlatformDxe/AcpiPlatformDxe.inf
 INF  RuleOverride=ACPITABLE OvmfPkg/AcpiTables/AcpiTables.inf
 
 INF  RuleOverride = BINARY FatBinPkg/EnhancedFatDxe/Fat.inf
Index: OvmfPkg/OvmfPkgX64.dsc
===================================================================
--- OvmfPkg/OvmfPkgX64.dsc	(revision 12124)
+++ OvmfPkg/OvmfPkgX64.dsc	(working copy)
@@ -79,6 +79,8 @@
   UefiApplicationEntryPoint|MdePkg/Library/UefiApplicationEntryPoint/UefiApplicationEntryPoint.inf
   DevicePathLib|MdePkg/Library/UefiDevicePathLib/UefiDevicePathLib.inf
   NvVarsFileLib|OvmfPkg/Library/NvVarsFileLib/NvVarsFileLib.inf
+  XenHypercallLib|OvmfPkg/Library/XenHypercallLib/XenHypercallLib.inf
+  XenLib|OvmfPkg/Library/XenLib/XenLib.inf
   FileHandleLib|ShellPkg/Library/UefiFileHandleLib/UefiFileHandleLib.inf
   UefiCpuLib|UefiCpuPkg/Library/BaseUefiCpuLib/BaseUefiCpuLib.inf
   SecurityManagementLib|MdeModulePkg/Library/DxeSecurityManagementLib/DxeSecurityManagementLib.inf
@@ -300,9 +302,12 @@
   }
 
   MdeModulePkg/Core/RuntimeDxe/RuntimeDxe.inf
+  #
+  # Xen PV Library Test
+  #
+  OvmfPkg/HypercallTestDxe/HypercallTestDxe.inf
   MdeModulePkg/Universal/SecurityStubDxe/SecurityStubDxe.inf
   MdeModulePkg/Universal/EbcDxe/EbcDxe.inf
-  MdeModulePkg/Universal/SmbiosDxe/SmbiosDxe.inf
   PcAtChipsetPkg/8259InterruptControllerDxe/8259.inf
   UefiCpuPkg/CpuIo2Dxe/CpuIo2Dxe.inf
   UefiCpuPkg/CpuDxe/CpuDxe.inf
@@ -316,6 +321,7 @@
   }
 
   PcAtChipsetPkg/PcatRealTimeClockRuntimeDxe/PcatRealTimeClockRuntimeDxe.inf {
+
     <LibraryClasses>
       TimerLib|OvmfPkg/Library/AcpiTimerLib/AcpiTimerLib.inf
   }
@@ -367,10 +373,16 @@
   IntelFrameworkModulePkg/Bus/Isa/IsaFloppyDxe/IsaFloppyDxe.inf
 
   #
+  # SMBIOS Support
+  #
+  MdeModulePkg/Universal/SmbiosDxe/SmbiosDxe.inf
+  OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.inf
+
+  #
   # ACPI Support
   #
   MdeModulePkg/Universal/Acpi/AcpiTableDxe/AcpiTableDxe.inf
-  MdeModulePkg/Universal/Acpi/AcpiPlatformDxe/AcpiPlatformDxe.inf
+  OvmfPkg/AcpiPlatformDxe/AcpiPlatformDxe.inf
   OvmfPkg/AcpiTables/AcpiTables.inf
 
   #
Index: OvmfPkg/OvmfPkgX64.fdf
===================================================================
--- OvmfPkg/OvmfPkgX64.fdf	(revision 12124)
+++ OvmfPkg/OvmfPkgX64.fdf	(working copy)
@@ -150,9 +150,12 @@
 INF  MdeModulePkg/Universal/PCD/Dxe/Pcd.inf
 
 INF  MdeModulePkg/Core/RuntimeDxe/RuntimeDxe.inf
+#
+# Xen PV Library Test
+#
+INF  OvmfPkg/HypercallTestDxe/HypercallTestDxe.inf
 INF  MdeModulePkg/Universal/SecurityStubDxe/SecurityStubDxe.inf
 INF  MdeModulePkg/Universal/EbcDxe/EbcDxe.inf
-INF  MdeModulePkg/Universal/SmbiosDxe/SmbiosDxe.inf
 INF  PcAtChipsetPkg/8259InterruptControllerDxe/8259.inf
 INF  UefiCpuPkg/CpuIo2Dxe/CpuIo2Dxe.inf
 INF  UefiCpuPkg/CpuDxe/CpuDxe.inf
@@ -198,8 +201,11 @@
 INF  IntelFrameworkModulePkg/Bus/Isa/Ps2KeyboardDxe/Ps2keyboardDxe.inf
 INF  IntelFrameworkModulePkg/Bus/Isa/IsaFloppyDxe/IsaFloppyDxe.inf
 
+INF  MdeModulePkg/Universal/SmbiosDxe/SmbiosDxe.inf
+INF  OvmfPkg/SmbiosPlatformDxe/SmbiosPlatformDxe.inf
+
 INF  MdeModulePkg/Universal/Acpi/AcpiTableDxe/AcpiTableDxe.inf
-INF  MdeModulePkg/Universal/Acpi/AcpiPlatformDxe/AcpiPlatformDxe.inf
+INF  OvmfPkg/AcpiPlatformDxe/AcpiPlatformDxe.inf
 INF  RuleOverride=ACPITABLE OvmfPkg/AcpiTables/AcpiTables.inf
 
 INF  RuleOverride = BINARY FatBinPkg/EnhancedFatDxe/Fat.inf
