Index: Universal/SmbiosDxe/SmbiosDxe.h
===================================================================
--- Universal/SmbiosDxe/SmbiosDxe.h	(revision 11711)
+++ Universal/SmbiosDxe/SmbiosDxe.h	(working copy)
@@ -109,3 +109,8 @@
 } EFI_SMBIOS_TABLE_END_STRUCTURE;
 
 #endif
+
+#define XEN_SMBIOS_PHYSICAL_ADDRESS       0x000EB000
+#define XEN_SMBIOS_PHYSICAL_END           0x000F0000
+
+
Index: Universal/SmbiosDxe/SmbiosDxe.c
===================================================================
--- Universal/SmbiosDxe/SmbiosDxe.c	(revision 11711)
+++ Universal/SmbiosDxe/SmbiosDxe.c	(working copy)
@@ -102,9 +102,64 @@
   0  
 };
 
+/**
+  Figures out if we are running inside Xen HVM.
 
+  @return UINT32     CPUID index used to connect to HV.
+
+**/
+UINT32
+XenDetect (
+  VOID
+  )
+{
+
+  UINT32 XenLeaf;
+  UINT8 Signature[13];
+
+  for (XenLeaf = 0x40000000; XenLeaf < 0x40010000; XenLeaf += 0x100) {
+    AsmCpuid (XenLeaf, NULL, (UINT32 *) &Signature[0],
+              (UINT32 *) &Signature[4],
+              (UINT32 *) &Signature[8]);
+    Signature[12] = '\0';
+
+    if (!AsciiStrCmp ((CHAR8 *) Signature, "XenVMMXenVMM")) {
+      return XenLeaf;
+    }
+  }
+
+  return 0;
+}
+
 /**
+  Figures out if Xen provides SMBIOS for HVM.
 
+  @return UINT32     Address of Xen hvmloader SMBIOS.
+
+**/
+UINT32
+XenSmbiosDetect (
+  VOID
+  )
+{
+
+  UINT32 XenSmbiosLeaf;
+  SMBIOS_TABLE_ENTRY_POINT *EntryPointStructurePhyAddr = NULL;
+
+  for (XenSmbiosLeaf = XEN_SMBIOS_PHYSICAL_ADDRESS; XenSmbiosLeaf < XEN_SMBIOS_PHYSICAL_END; XenSmbiosLeaf += 0x1) {
+
+    EntryPointStructurePhyAddr = (SMBIOS_TABLE_ENTRY_POINT *) (UINTN) XenSmbiosLeaf;
+
+    if (!AsciiStrnCmp ((CHAR8 *) EntryPointStructurePhyAddr->AnchorString, "_SM_", 4) && !AsciiStrnCmp ((CHAR8 *) EntryPointStructurePhyAddr->IntermediateAnchorString, "_DMI_", 5)) {
+      return XenSmbiosLeaf;
+    }
+  }
+
+  return 0;
+}
+
+/**
+
   Get the full size of smbios structure including optional strings that follow the formatted structure.
 
   @param This                   The EFI_SMBIOS_PROTOCOL instance.
@@ -794,11 +849,85 @@
   EFI_PHYSICAL_ADDRESS            PhysicalAddress;
   EFI_SMBIOS_TABLE_HEADER         *SmbiosRecord;
   EFI_SMBIOS_TABLE_END_STRUCTURE  EndStructure;
+
+  UINT32                          XenLeaf;
+  UINT32                          XenSmbiosLeaf;
   
   Status            = EFI_SUCCESS;
   BufferPointer     = NULL;
+  XenSmbiosLeaf     = 0;
 
   //
+  //If we are running inside Xen HVM, try to find out whether Xen hvmloader provides SMBIOS
+  //
+  XenLeaf = XenDetect ();
+  if (XenLeaf) {
+    XenSmbiosLeaf = XenSmbiosDetect();
+  }
+
+  //
+  //If we are running inside Xen HVM and Xen hvmloader SMBIOS exists, just copy it to OVMF SMBIOS
+  //
+  if (XenLeaf && XenSmbiosLeaf) {
+    //
+    // Initialize the EntryPointStructure with initial values.
+    //
+    if (EntryPointStructure == NULL) {
+      //
+      // Allocate memory to SMBIOS Entry Point Structures (below 4GB)
+      //
+      PhysicalAddress = 0xffffffff;
+      Status = gBS->AllocatePages (
+                     AllocateMaxAddress,
+                     EfiReservedMemoryType,
+                     EFI_SIZE_TO_PAGES (sizeof (SMBIOS_TABLE_ENTRY_POINT)),
+                     &PhysicalAddress
+                    );
+      if (EFI_ERROR (Status)) {
+        return EFI_OUT_OF_RESOURCES;
+      }
+
+      EntryPointStructure = (SMBIOS_TABLE_ENTRY_POINT *) (UINTN) PhysicalAddress;
+    
+      CopyMem (
+        EntryPointStructure,
+        (VOID *) (UINTN) XenSmbiosLeaf,
+        sizeof (SMBIOS_TABLE_ENTRY_POINT)
+       );
+    }
+
+    //
+    // Allocate memory to Structure Table (below 4GB)
+    //
+    PhysicalAddress = 0xffffffff;
+    Status = gBS->AllocatePages (
+                    AllocateMaxAddress,
+                    EfiReservedMemoryType,
+                    EFI_SIZE_TO_PAGES (EntryPointStructure->TableLength),
+                    &PhysicalAddress
+                    );
+    if (EFI_ERROR (Status)) {
+      FreePages ((VOID*) EntryPointStructure, EFI_SIZE_TO_PAGES (sizeof (SMBIOS_TABLE_ENTRY_POINT)));
+      EntryPointStructure = NULL;
+      return EFI_OUT_OF_RESOURCES;
+    }
+
+    CopyMem (
+      (VOID *) (UINTN) PhysicalAddress,
+      (VOID *) (UINTN) EntryPointStructure->TableAddress,
+      EntryPointStructure->TableLength
+     );
+
+    EntryPointStructure->TableAddress = (UINT32) PhysicalAddress;
+
+    //
+    // Returns the pointer
+    //
+    *TableEntryPointStructure = EntryPointStructure;
+
+  }
+  else {
+  //
   // Initialize the EntryPointStructure with initial values.
   //
   if (EntryPointStructure == NULL) {
@@ -946,6 +1075,7 @@
   // Returns the pointer
   //
   *TableEntryPointStructure = EntryPointStructure;
+}
 
   return EFI_SUCCESS;
 }
